#+title: Emacs Configuration

This is my literate emacs confguration which I intend  to use for all of my computing needs.

* Introduction
** Package Management

This is where this configuration differs from most others. Emacs has a wide variety of package management solutions, internally like ~package.el~ or externally like ~use-package~ or ~straight.el~. However, the problem persists is that any emacs configuration has implied external dependencies, say nodejs for writing javascript projects.  Where I differ is that I use Nix to manage both of the elisp package dependencies and the external dependencies. This is the general rule but a large exception is where software projects using Nix also maintain their own dependencies using shell hooks. This would also be a good idea to incorporate where a project buffer rationalises whethers the project is /"nixified"/ and if not will attempt to download those dependencies, or at least make the user aware that it is not available.  Not to digress, because the elisp packages are pre-installed, all that has to be done is to ~require~ them in a file and so removes a lot of unneccessary juggling of ~use-package~.

As this is a nixified emacs literate config, I use a flake to define an emacs package which contains all required dependencies. This may also be moved to inside my notes as externally referencing pieces of my configuration could be useful for blogging/research.

One pain point which may manifest is that the emacs-overlay which the flake uses becomes unmaintained or does not declare a package I want. A workaround could be to use ~straight.el~.

** Useful Links

- http://alhassy.com/emacs.d/index.html
- https://gitlab.com/public-repositories/emacs-groundup
- https://github.com/alphapapa/unpackaged.el
- http://honnef.co/articles/my-org-roam-workflows-for-taking-notes-and-writing-articles
- https://karelvo.com/blog/2023-02-17-orgmode
- https://www.sobyte.net/post/2022-05/emacs-package/
- https://www.brettwitty.net/exocortex.html
- https://github.com/technomancy/emacs-starter-kit  
- https://nullprogram.com/blog/2017/01/30/
- Prefer custom-set-variable(s) over setq https://emacs.stackexchange.com/questions/102/advantages-of-setting-variables-with-setq-instead-of-custom-el
- Similar to above, use setopt for emacs 29+ https://emacs.stackexchange.com/questions/78419/im-unsure-which-option-to-use-for-setting-a-variable-setq-customize-set-varia/78424#78424
- https://github.com/frap/emacs-literate
- Uses nix! https://panadestein.github.io/emacsd/
- https://github.com/caisah/emacs.dz
- https://github.com/alopezrivera/Seaman-Emacs/blob/main/seaman/seaman.org#base-configuration 
- https://emacsdocs.org/

* Prerequisites

Firstly, the configuration listed here should be executed first

** Emacs Configuration Header

Emacs has a [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html][convention]] which must be complied with when publishing elisp code.

#+begin_src emacs-lisp
;;; config.el --- Padraic's Emacs configuration -*- lexical-binding: t -*-

;; Copyright (C) 2023-2023 Patrick H Morris

;; Author: Patrick H Morris <patrick.morris.310@gmail.com>
;; Keywords: internal
;; URL: https://panadestein.github.io/emacsd/

;;; Commentary:
;; A fully fledged, reproducible Emacs configuration

;;; Code:
#+end_src

Note that this also specifies the usage of lexical binding. See https://nullprogram.com/blog/2016/12/22/ for an explaination. This should always be placed at the top of the file.

** Require locally defined functions

The function section places functions in a different file, ~functions.el~ which should be loaded at the start.

#+begin_src emacs-lisp
(load-file (concat user-emacs-directory "functions.el"))
#+end_src

** Disable Magic File Names on Startup

The ~file-name-handler-alist~ is a special variable containing lookup keys for handlers when accessing a particular file, it's not used at startup so we can disable it temporarily.

#+begin_src emacs-lisp
(defvar file-name-handler-alist-original file-name-handler-alist)
(setq file-name-handler-alist nil)
#+end_src

Restore it later using the ~emacs-startup-hook~

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (setq file-name-handler-alist file-name-handler-alist-original)))
  #+end_src

** Garbage Collection

We set the gc threshold to ~most-positive-fixnum~, which is the largest representable positive integer in elisp. Also increasing ~gc-cons-percentage~ increases memory usage before garbage collection.

#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.6)
#+end_src

Assign variable for the desired gc threshold

#+begin_src emacs-lisp
(defvar pm/gc-cons-threshold 100000000)
#+end_src

Reset gc once emacs has initialised

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook ; hook run after loading init files
          (lambda ()
            (setq gc-cons-threshold pm/gc-cons-threshold
                  gc-cons-percentage 0.1
                  file-name-handler-alist file-name-handler-alist-original)))
#+end_src

Ensure minibuffer operations are smooth

#+begin_src emacs-lisp
(add-hook 'minibuffer-setup-hook
          #'(lambda ()
              (setq gc-cons-threshold (* pm/gc-cons-threshold 2))))
(add-hook 'minibuffer-exit-hook
          #'(lambda ()
              (garbage-collect)
              (setq gc-cons-threshold pm/gc-cons-threshold)))
#+end_src

** Native Compilation

Check if native compilation is available for this emacs instance and if so configures native compilation settings and the path for where the compiled elisp files are stored which is the users emacs directory.

#+begin_src emacs-lisp
(when (and (fboundp 'native-comp-available-p) (native-comp-available-p))
  (progn
    (setq native-comp-async-report-warnings-errors nil)
    (setq native-comp-deferred-compilation t)
    (add-to-list 'native-comp-eln-load-path (expand-file-name "eln-cache/" user-emacs-directory))
    (setq package-native-compile t)))
#+end_src

This block might be unnecessary.

** Initialization Flag

This is a useful variable which can be used to mitigate issues surrounding reloading of the confi

#+begin_src emacs-lisp
(defvar pm/initialized nil)

(add-hook 'emacs-startup-hook
          #'(lambda ()
              (setq pm/initialized t)))
#+end_src

* Basic Emacs Settings

Modifications to the default emacs settings should exist here. No
external package should be referenced.

** Personal Configuration

Basic user information

#+begin_src emacs-lisp
(setq user-full-name "Patrick H Morris"
      user-mail-address "patrick.morris.310@gmail.com")
#+end_src 

** Init Files

Emacs has a variety of conventions of files which should be loaded and where certain configuration can exist. Anything related to that behaviour should go here

*** Default.el

This is quite important in context of how this emacs configuration is defined. This file may be used to generate a ~default.el~ file which is custom packaged with emacs. In such cases, having this setting be true would prevent that file from loading.

#+begin_src emacs-lisp
(setq inhibit-default-init t)
#+end_src

*** Custom.el

Define the custom file to exist within the user's emacs directory

#+begin_src emacs-lisp
(let ((customization-file
       (expand-file-name "custom.el" user-emacs-directory)))
  (unless (file-exists-p customization-file)
    (write-region "" nil customization-file))
  (setq custom-file customization-file)
  (load custom-file 'noerror))
#+end_src

https://panadestein.github.io/emacsd/#orgaf16e18

** Startup

Prevent the startup screen containing Emacs specific content/documentation/links

#+begin_src emacs-lisp
(setq inhibit-startup-message t)
#+end_src

Prevent the echo area startup message. ~inhibit-startup-echo-area-message~ has little to no affect, maybe for advertising reasons, either way the source of the message is in the function ~display-startup-echo-area-message~ which is overrided here in order to change the message.

#+begin_src emacs-lisp
(defun display-startup-echo-area-message ()
  (display-startup-time))
#+end_src

*** Initial Buffer

Decide what buffers should be opened by default. When customising emacs it is easiest to open this file and the messages buffer for any information

#+begin_src emacs-lisp
(setq initial-buffer-choice "~/.config/emacs/config.org")
#+end_src

**** TODO Define a sensible startup system

Maybe Agenda/Daily?

*** Scratch Buffer

Make the scratch buffer empty by default

#+begin_src emacs-lisp
(setq initial-scratch-message nil)
#+end_src

** File/Buffer/Text Behaviour

Configuration pertaining to global file behaviour should go here

*** Large File Warnings
Warn when opening files greater than 100MB

#+begin_src emacs-lisp
(setq large-file-warning-threshold 100000000)
#+end_src

*** Respect File Mutation

Should a file be modified outside of Emacs, always respect those changes. Also check for file changes every second, if this becomes an issue for performance, increase

#+begin_src emacs-lisp
(global-auto-revert-mode t)
(setq auto-revert-interval 1)
#+end_src

*** Always use UTF8

#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
#+end_src

*** Don't Make Backups

#+begin_src emacs-lisp
(setq make-backup-files nil)
#+end_src

*** End Sentence with Single Space

#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src
*** Don't save modified buffers on exit

If a buffer is "unsaved" when killing it, you will get an annoying prompt to save. If not saved, I want to just kill immediately

#+begin_src emacs-lisp
(defun pm/suppress-save-buffer-query-function ()
  (set-buffer-modified-p nil)
  t) ; Return t so other functions in kill-buffer-query-functions get called.

(add-to-list 'kill-buffer-query-functions 'pm/suppress-save-buffer-query-function)
#+end_src

** UI

*** Remove Features

Emacs by default comes with a clunky ugly interface, remove those features.

#+begin_src emacs-lisp
(scroll-bar-mode -1)
(tool-bar-mode -1)
(tooltip-mode -1)
(set-fringe-mode 10)
(menu-bar-mode -1)
#+end_src

*** Bell Modifications

Emacs comes with an audible bell sound when a user does someting erroneous. Having this be a visual feature is preferred.

#+begin_src emacs-lisp
(setq visible-bell t)
#+end_src

Disable it to be sure

#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src

*** Mitigate Blinking Cursor

#+begin_src emacs-lisp
(blink-cursor-mode -1)
#+end_src
*** Scrolling

#+begin_src emacs-lisp
(setq scroll-margin 0
      scroll-conservatively 100000
      scroll-preserve-screen-position 1)
#+end_src
** Y/N Prompt

Ensure all yes/no type queries can be answered with y/n

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src
** Debugging

Emacs enables debugging using the ~--debug-init~ flag. The configuration below increases the verbosity of warnings in such contexts.

#+begin_src emacs-lisp
(if init-file-debug
    (setq warning-minimum-level :debug)
  (setq warning-minimum-level :emergency))
#+end_src
** History

~savehist~ (short for "save history") is a built-in feature of Emacs that allows you to persistently save various history lists across Emacs sessions. This means that things like your command history, search history, and other similar histories can be remembered even after you close and restart Emacs.

#+begin_src emacs-lisp
(require 'savehist)
(savehist-mode)
#+end_src
** Littering

~no-littering~ sets sane defaults for a host of backup files etc that can build up

#+begin_src emacs-lisp
(require 'no-littering)
#+end_src

* Keybindings

It is better to define the keybinding system early as subsequent
functionality is dependent

** ~general.el~

~general~ is a keybinding framework for emacs and is complementary to evil mode users. ~SPC~ will be a global key to manage a lot of behaviour

#+begin_src emacs-lisp
(require 'general)
(general-evil-setup t)

(general-create-definer pm/leader
  :keymaps '(normal insert visual emacs)
  :prefix "SPC"
  :global-prefix "C-SPC")
#+end_src

** ~which-key~

~which-key~ enhances the Emacs experience by providing real-time, interactive feedback on keybindings, making it easier to navigate and use the vast array of commands and functionalities available in the editor.

#+begin_src emacs-lisp
(require 'which-key)
(which-key-mode)
(setq which-key-idle-delay 0)
#+end_src
** Global Keybindings

Here is a space for defining all global keybindings

*** Bucket

For keybindings which haven't found their place in the config.

#+begin_src emacs-lisp
(pm/leader
  "r" '(pm/reload-config :which-key "Reload config")
  "u" '(:ignore t :which-key "ui")
  "ut" '(counsel-load-theme :which-key "Select Theme"))
#+end_src

*** Esc Acts as Quit

By default, ~C-g~ will quit a process which is slightly more work than ~<escape>~

#+begin_src emacs-lisp
(general-define-key
 "<escape>" 'keyboard-escape-quit)
#+end_src

* Display

Configuration regarding the emacs appearence should go here

** Theme

doom-themes is a popular collection of emacs themes. 

#+begin_src emacs-lisp
(require 'doom-themes)
(setq doom-themes-enable-bold t    
      doom-themes-enable-italic t)

(unless pm/initialized (load-theme 'doom-nord-aurora t)) 
(doom-themes-visual-bell-config)
(doom-themes-org-config)
#+end_src
** Font

Iosevka is a nice font

#+begin_src emacs-lisp
(set-face-attribute 'default nil :font "Iosevka Comfy Fixed" :height 100)
#+end_src 

** Icons

#+begin_src emacs-lisp
(require 'all-the-icons)
#+end_src

** Modeline

Also borrowing from the doom collection

#+begin_src emacs-lisp
(require 'doom-modeline)
(doom-modeline-mode t)
(setq doom-modeline-height 55)
(setq doom-modeline-buffer-file-name-style 'relative-to-project)
(setq doom-line-numbers-style 'relative)
(setq doom-modeline-major-mode-icon t)
(setq doom-modeline-buffer-state-icon t)
(setq doom-modeline-major-mode-color-icon t)
(setq doom-modeline-window-width-limit nil)
#+end_src
** Windows
*** Fringe

The "fringe" is the narrow vertical areas on either side of windows

#+begin_src elisp
(set-fringe-mode 0)
#+end_src
*** Winner

#+begin_src elisp
(require 'winner)
(winner-mode t)
#+end_src
*** Selection

#+begin_src emacs-lisp
(require 'ace-window)
(setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
#+end_src
* Editing

File editing is the most important thing an editor does right?!?!

** Text Behaviour
*** Long Lines

Emacs has historically had severe performance issues with files that contain long lines.

#+begin_src emacs-lisp
(require 'so-long)
#+end_src

Add the global mode once initialisation has finished as it 

#+begin_src emacs-lisp
(add-hook 'after-init-hook 'global-so-long-mode)
#+end_src

*** Filling/Wrapping

Define a variable to be used to specify column width

"Filling" refers to the process of breaking lines of text to fit within a specified width, which is typically the value of the ~fill-column~ variable. This action ensures that text is neatly wrapped and presented within the confines of a set width, making it more readable and visually organized, especially in text modes.

#+begin_src emacs-lisp
(setq fill-column 80)
#+end_src

It is probably not desirable to fill unless the user specifies directly. Enabling visual line wrapping is preferable as it does not alter the file in order to make the editing experience more appealing. The desired effect can be achieved using ~visual-line-mode~ which wraps text which goes past a certain point but maintains the same line. "Filling" can be opted in using one of the many commands like ~evil-fill~ 

Wrapping is where text is shown on the same line but the pane width is respected such that the line "wraps" around the screen. ~visual-line-mode~ is a minor mode in Emacs that affects how lines of text are displayed in the buffer, without modifying the actual content of the file. When this mode is enabled, long lines of text are visually wrapped at the edge of the window, making them appear as multiple lines on the screen, even though they remain a single line in the file.

We only want to turn this on for text and programming modes as things like the minibuffer and terminals should not need to do this

#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'visual-line-mode)
(add-hook 'prog-mode-hook 'visual-line-mode)
#+end_src

However, ~visual-line-mode~ will wrap only at the window edge which could mean arbitrarily long lines if the window is the full screen width. Alternatively, using ~visual-fill-column~ package allows for soft wrapping at a specific column which is referenced by ~pm/column-width~. This should make text wrapping occur at that column width or if the pane is smaller. This should make for a better reading experience.

https://codeberg.org/joostkremers/visual-fill-column

Here, I've increased the column width as the default ~fill-column~ is too narrow at 80. Most programming modes ought to provide their own prettification tooling which should override any text wrapping. "Filling" can be left manual and only used when align code commentary or things of that ilk.

#+begin_src emacs-lisp
(require 'visual-fill-column)
(add-hook 'visual-line-mode-hook
          #'(lambda ()
              (setq visual-fill-column-width 140) 
              (visual-fill-column-mode)))
#+end_src

https://github.com/seagle0128/doom-modeline/issues/672

Always ensure that the modeline is aligned as far right
#+begin_src emacs-lisp
(setq mode-line-right-align-edge 'right-fringe)
#+end_src

*** Tabs vs Spaces

Don't trust tabs

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq tab-width 2)
#+end_src

The tab-always-indent variable essentially allows users to configure a balance between indentation and completion behaviors, based on their preferences and workflow. Some users prefer the TAB key to prioritize indentation, while others might want it to emphasize completion, especially in modes or contexts where completion is frequently used.

When ~tab-always-indent~ is set to ~complete~, pressing TAB will first try to indent the current line. If the line is already correctly indented, or if the point isn't at the beginning of a line, Emacs will then try to perform completion.

#+begin_src emacs-lisp
(setq-default tab-always-indent 'complete)
#+end_src

** ~evil~

For those who like to use vim in emacs

#+begin_src emacs-lisp
(setq evil-want-integration t)
(setq evil-want-keybinding nil)
(setq evil-want-C-u-scroll t)
(setq evil-want-C-i-jump nil)
(setq evil-undo-system 'undo-tree)

(require 'evil)
(evil-mode 1)

(require 'evil-collection)
(evil-collection-init)

(evil-set-initial-state 'messages-buffer-mode 'normal)
(evil-set-initial-state 'dashboard-mode 'normal)
#+end_src

#+begin_src emacs-lisp
(general-def 'evil-insert-state-map
  "C-g" 'evil-normal-state
  "C-h" 'evil-delete-backward-char-and-join)

(general-define-key 
 :states 'motion
 "j" 'evil-next-visual-line
 "k" 'evil-previous-visual-line)
#+end_src

** ~undo-tree~

A very nice visualisation tool for tracing file changes in a tree hierarchy

#+begin_src emacs-lisp
(require 'undo-tree)
(general-define-key
 "C-x u" 'undo-tree-visualize)

(global-undo-tree-mode)
(setq undo-tree-visualizer-timestamps t)
(setq undo-tree-visualizer-diff t)
(setq undo-tree-show-help-in-visualize-buffer t)
(setq undo-tree-auto-save-history t)
(setq undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "undo"))))
#+end_src

* Git
** ~magit~

The best git gui ever made

#+begin_src emacs-lisp
(require 'magit)
(setopt magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1) ; What does this do?
#+end_src

#+begin_src emacs-lisp
(pm/leader
  "m" '(:ignore t :which-key "magit")
  "mm" '(magit-status :which-key "status"))
#+end_src
* Org

/Org/ is a versatile and powerful mode in Emacs designed for keeping notes, maintaining to-do lists, planning projects, and authoring documents. It's built around a plain-text formatting system, making it platform-independent and easily readable outside of Emacs. Over the years, /Org/ has evolved into a robust toolset that can handle everything from personal task management to publishing, coding, and even scientific research.

#+begin_src emacs-lisp
(require 'org)
#+end_src

Also create a general.el keybind for org mode contexts

#+begin_src emacs-lisp
(pm/leader
  "o" '(:ignore t :which-key "org"))
#+end_src

** Appearence and Behaviour

*** Ellipsis

Replaces the default content marker, "⋯", with a nice unicode arrow.

#+begin_src emacs-lisp
(setq org-ellipsis " ⤵")
#+end_src

*** Bullets

/Org-bullets/ is an Emacs package designed to enhance the visual appearance of Org-mode documents by replacing the standard asterisks (*) used for headlines with more visually appealing bullet characters.

#+begin_src emacs-lisp
(require 'org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+end_src

*** Indentation

Content under org headings will be indented such that it is clear under which heading content is nested.

#+begin_src emacs-lisp
(setq org-startup-indented t)
(add-hook 'org-mode-hook 'org-indent-mode)
#+end_src

*** Markers

Markers relate to the markup syntax used to provide different kinds of text styling.

#+begin_src emacs-lisp
(setq org-hide-emphasis-markers t)
#+end_src

**** TODO Add a font which works well with the different kinds of syntax highlighting

*** Code Blocks

In Org mode within Emacs, code blocks (often referred to as "source blocks") allow for the inclusion of source code from various programming languages. These blocks can be used for documentation, literate programming, or for dynamically generating content within an Org document.

One of the powerful features of source blocks in Org mode is that they can be executed. By placing the cursor within a source block and pressing C-c C-c, you can run the code if Emacs is configured to support that particular language. The results can be inserted directly into the Org document.

**** Template Tab Completion

Since org-mode 9.2, the completion ~<s TAB~ does not work out of the box and so org-tempo is required

Also adds the completion for elisp source code blocks using ~<el TAB~

#+begin_src emacs-lisp
(require 'org-tempo)
(add-to-list 'org-structure-template-alist
             '("el" . "src emacs-lisp"))
#+end_src

**** Indentation

Ensures that source code blocks are aligned with the left-most column.

#+begin_src emacs-lisp
(setq org-src-preserve-indentation t)
#+end_src

Make Tab respect indentation of the major mode for the lang

#+begin_src emacs-lisp
(setq org-src-tab-acts-natively t)
#+end_src

**** Evaluation

Don't ask permission to evaluate. Evaluation can be done using the Keybinding ~C-c C-c.~

#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src

*** Folding

Fold headings at start

#+begin_src emacs-lisp
(setq org-startup-folded t)
#+end_src

*** Timestamp

We always want to record for each org file when it was last edited

#+begin_src emacs-lisp
(require 'time-stamp)

(setq time-stamp-active t)
(setq time-stamp-start "#\\+last_modified:[ \t]")
(setq time-stamp-end "$")
(setq time-stamp-format "\[%Y-%m-%d %a %H:%M\]")

(add-hook 'before-save-hook #'time-stamp)
#+end_src

*** Links

Naked urls are fine but it is preferred to use ~org-cliplink~ as a way to gather extra info

#+begin_src emacs-lisp
(require 'org-cliplink)
#+end_src

*** Graphs

#+begin_src emacs-lisp
(setq ob-mermaid-cli-path (getenv "MERMAID_CLI"))
(add-to-list 'org-babel-load-languages '(mermaid . t))

(add-to-list 'org-structure-template-alist
             '("mrm" . "src mermaid :file /tmp/test.png"))
#+end_src

**** TODO Add inline images for  working!!
*** Miscellaneous

Prevents edits to content hidden under a folded heading

#+begin_src emacs-lisp
(setq org-catch-invisible-edits t)
#+end_src

** Tasks

Org mode in Emacs for task management is a powerful way to organize, prioritize, and track tasks and projects. The flexibility of Org mode allows users to create a system tailored to their unique needs.

*** ~TODO~ States

By default, org mode provides two states, ~TODO~ and ~DONE~ which are used to describe and manage a task. The below keyword states provide a base outline on how tasks are defined and managed across the duration of their lifetime.

Extending this behaviour we can add more states which offer a generic way of tracking any arbitrary task.

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence
         "TODO(t)" ;; A task that needs doing and is ready to do
         "PROG(p!)" ;; A task that is in progress
         "NEXT(n!)" ;; A task which should be done next
         "WAIT(w@/!)" ;; A task which is held up for an external reason
         "HOLD(h@/!)" ;; A task which is paused
         "|" ;;
         "DONE(d!)" ;; When a task is completed
         "KILL(k@/!)" ;; When a task is rejected
         "FAIL(f@/!)" ;; When a task is failed
         )
        (sequence
         "NOTE" ;; Not necessary for agenda, just for highlighting in places
         "LINK" ;; A naked url which is to be changed to a link note
         "IDEA" ;; A piece of information which might manifest into something
         "|")))
#+end_src

It is to be noted that TODO states can be defined per-file, which may come in handy for prescribing behaviour for certain notes/documents.

#+begin_src emacs-lisp
(setq org-log-done 'note)
(setq org-log-into-drawer t) 
#+end_src

*** Block ~DONE~ state for TODOs with dependent children TODOs

Should a TODO heading contain nested TODOs, then all nested TODOs must be put in a finished state

#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
#+end_src

*** Create custom hook which for ~org-insert-todo-heading~

As org-mode does not come with a hook for ~org-insert-todo-heading~ we want to add one for lines beginning

#+begin_src emacs-lisp
(defun pm/run-org-insert-todo-heading-hook (&rest _)
  "Run `pm/org-insert-todo-heading-hook'."
  (run-hooks 'pm/org-insert-todo-heading-hook))

(advice-add 'org-insert-todo-heading :after 'pm/run-org-insert-todo-heading-hook)
(advice-add 'org-insert-todo-heading-respect-content :after 'pm/run-org-insert-todo-heading-hook)
(advice-add 'org-insert-todo-subheading :after 'pm/run-org-insert-todo-heading-hook)

;; (add-hook 'org-after-todo-state-change-hook #'my/log-todo-creation-date)
#+end_src

#+begin_src emacs-lisp
(setopt org-insert-heading-respect-content t)
(setopt org-insert-todo-heading-respect-content t)
#+end_src

*** ~CREATED~ metadata timestamp

For any ~TODO~ heading, a ~SCHEDULED~ or ~DEADLINE~  and ~CLOSED~ timestamp metadata can be assigned. This is useful metadata but also including ~CREATED~ would be useful.

We define the 4 timestamp kinds:

And then add a specialised function always adds a ~CREATED~ timestamp property. 

#+begin_src emacs-lisp
(require 'org-expiry)

(defun pm/org-add-created-timestamp ()
  (save-excursion
    (org-back-to-heading)
    (org-set-property "CREATED"
                      (format-time-string
                       (org-time-stamp-format 'long 'inactive)
                       (org-current-time)))))

(add-hook 'pm/org-insert-todo-heading-hook 'pm/org-add-created-timestamp) 
#+end_src
*** Add ~ORDERED~ property for any TODO heading

The ~ORDERED~ property restricts sequential TODO's under a heading to be assigned as ~DONE~ until the previous ~TODO~ is. This enforces that tasks and subtasks are described in the order they are to be completed. 

#+begin_src emacs-lisp
;; (defun pm/org-todo-heading-add-ordered-property ()
;;   (when (org-at-heading-p)
;;     (org-set-property "ORDERED" "t")))

;; (add-hook 'pm/org-insert-todo-heading-hook 'pm/org-todo-heading-add-ordered-property)
#+end_src

** Notes
*** Initialisation

#+begin_src emacs-lisp
(require 'org-roam)
(setopt org-directory "~/notes"
        org-roam-directory org-directory
        org-roam-dailies-directory "daily/")
(setq org-roam-database-connector 'sqlite-builtin)
(org-roam-db-autosync-mode)

(pm/leader
  "n" '(:ignore t :which-key "notes"))
#+end_src

#+begin_src emacs-lisp
(defun pm/return-t (orig-fun &rest args) t)
(defun pm/disable-yornp (orig-fun &rest args)
  (advice-add 'yes-or-no-p :around #'pm/return-t)
  (advice-add 'y-or-n-p :around #'pm/return-t)
  (let ((res (apply orig-fun args)))
    (advice-remove 'yes-or-no-p #'pm/return-t)
    (advice-remove 'y-or-n-p #'pm/return-t)
    res))
(advice-add 'org-roam-capture--finalize :around #'pm/disable-yornp)

#+end_src
*** Display

#+begin_src emacs-lisp
(defun pm/rpartial (fn &rest args)
  "Return a partial application of FUN to right-hand ARGS.

ARGS is a list of the last N arguments to pass to FUN. The result is a new
function which does the same as FUN, except that the last N arguments are fixed
at the values with which this function was called."
  (declare (side-effect-free t))
  (lambda (&rest pre-args)
    (apply fn (append pre-args args))))

(cl-defmethod org-roam-node-pm/filetitle ((node org-roam-node))
  "Return the value of \"#+title:\" (if any) from file that NODE resides in.
If there's no file-level title in the file, return empty string."
  (or (if (= (org-roam-node-level node) 0)
          (org-roam-node-title node)
        (org-roam-node-file-title node))
      ""))

(cl-defmethod org-roam-node-pm/hierarchy ((node org-roam-node))
  "Return hierarchy for NODE, constructed of its file title, OLP and direct title.
If some elements are missing, they will be stripped out."
  (let ((title     (org-roam-node-title node))
        (olp       (org-roam-node-olp   node))
        (level     (org-roam-node-level node))
        (filetitle (org-roam-node-pm/filetitle node))
        (separator (propertize "<>" 'face 'shadow)))
    (cl-case level
      ;; node is a top-level file
      (0 filetitle)
      ;; node is a level 1 heading
      (1 (concat (propertize filetitle 'face '(shadow italic))
                 separator title))
      ;; node is a heading with an arbitrary outline path
      (t (concat (propertize filetitle 'face '(shadow italic))
                 separator (propertize (string-join olp separator) 'face '(shadow italic))
                 separator title)))))

(cl-defmethod org-roam-node-pm/type ((node org-roam-node))
  "Return the directory relative to `org-roam-directory' as a note's \"type\"."
  (when-let (dir (thread-first
                   node
                   (org-roam-node-file)
                   (file-relative-name org-roam-directory)
                   (file-name-directory)))
    (directory-file-name dir)))

(cl-defmethod org-roam-node-pm/tags ((node org-roam-node))
  "Return tags formatted in the same way how they appear in org files."
  (cl-remove-if (pm/rpartial
                 #'member (delq
                           nil (append
                                (list (bound-and-true-p org-archive-tag)
                                      (bound-and-true-p org-attach-auto-tag))
                                (bound-and-true-p org-num-skip-tags))))
                (org-roam-node-tags node)))

(setq org-roam-node-display-template
      (format "${pm/hierarchy:*} %s %s"
              (propertize "${pm/type}" 'face 'font-lock-keyword-face)
              (propertize "${pm/tags:*}" 'face '(:inherit org-tag :box nil))))

(add-to-list 'org-roam-node-template-prefixes '("pm/tags" . "#"))
(add-to-list 'org-roam-node-template-prefixes '("pm/type" . "@"))
#+end_src
*** Templates
**** Entries

***** Basic Entry

#+begin_src emacs-lisp
(defvar pm/note-basic-entry (pm/template-entry-builder :entry-content "%?" :no-properties t))
#+end_src
***** Todo Entry


#+begin_src emacs-lisp
(defvar pm/note-todo-entry (pm/template-entry-builder :todo-state "TODO" :levels 2 :title-content "%?"))
#+end_src

***** Journal Entry

#+begin_src emacs-lisp
(defvar pm/note-journal-entry (pm/template-entry-builder :title-content "[%<%T>]\n %?" :levels 2 :no-properties t))
#+end_src

***** Idea Entry

#+begin_src emacs-lisp
(defvar pm/note-idea-entry (pm/template-entry-builder :todo-state "IDEA" :levels 2 :title-content "%?"))
#+end_src

***** Link Entry (From Clipboard)

#+begin_src emacs-lisp
(defvar pm/note-link-entry (pm/template-entry-builder
                            :no-properties t
                            :title-content "%(org-cliplink-capture)"))
#+end_src
**** Names

***** Default

#+begin_src emacs-lisp
(defvar pm/default-note-name-template "%<%s>__${slug}.org")
#+end_src

***** Project

#+begin_src emacs-lisp
(defvar pm/project-note-name-template "project/${slug}.org")
#+end_src

***** Daily

#+begin_src emacs-lisp
(defvar pm/daily-note-name-template "%<%Y-%m-%d>.org")
#+end_src

***** Person

#+begin_src emacs-lisp
(defvar pm/people-note-name-template "people/<%s>__${slug}.org")
#+end_src
**** Targets

***** Basic

#+begin_src emacs-lisp
(defvar pm/basic-note-target `(file+head ,pm/default-note-name-template ,(pm/template-head-builder)))
#+end_src

***** Action

#+begin_src emacs-lisp
(defvar pm/action-note-target
  `(file+head
    ,pm/default-note-name-template
    ,(pm/template-head-builder
      :headings '("Journal" "Tasks" "Ideas" "Links")
      )))
#+end_src
**** Generic
***** Basic Note Template
#+begin_src emacs-lisp
(defvar pm/basic-note-template
  `("d" "" plain
    pm/note-basic-entry
    :target ,pm/basic-note-target
    :unnarrowed t
    :empty-lines-before 1))
#+end_src
*** Finding
**** Prompt

#+begin_src emacs-lisp
(defvar pm/note-find-prompt "<[Note]> ")
#+end_src
**** Leader key

#+begin_src emacs-lisp
(pm/leader
  "nf" '(:ignore t :which-key "find notes"))
#+end_src

**** Find matching note

Default org-roam has awkward fallback process when finding notes. If a note does not exist, it will immediately go into a capture process which is not exactly desired

#+begin_src emacs-lisp
(cl-defun pm/note-read (&key (initial-input nil)
                             (filter-fn nil)
                             (sort-fn nil)
                             (require-match nil)
                             (prompt pm/note-find-prompt))
  (org-roam-node-read initial-input filter-fn sort-fn require-match prompt))

(cl-defun pm/note-find ()
  (interactive)
  (org-roam-node-visit (pm/note-read :require-match t) t))

(pm/leader
  "nf" '(pm/note-find :which-key "find note"))
#+end_src

**** TODO Find note by tag(s)
**** TODO Find project notes
**** TODO Find people notes
**** TODO Find link notes
**** TODO Find daily notes
*** Searching
*** Capturing

Capturing is the central component to how the note system should work. Ideally, the flow should work as a way to automate editing or creation of notes in a simple form. 

**** Generic

A generic note is self-explanatory, just a basic unopinionated note type. As mentioned, there is two approaches, creating new notes and editing of currently existing notes. For capturing new notes:

#+begin_src emacs-lisp
(cl-defun pm/note-capture-new (&key node)
  (interactive)
  (if node
      (org-roam-capture-
       :goto nil
       :info nil
       :keys nil
       :templates `(("a" "Basic note" plain
                     ,pm/note-basic-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder)))
                    ("b" "Basic note + alias prompt" plain
                     ,pm/note-basic-entry
                     :target (file+head
                              ,pm/default-note-name-template
                              ,(pm/template-head-builder :aliases `("%^{ALIAS}"))))
                    ("c" "Basic note + tag prompt" plain
                     ,pm/note-basic-entry
                     :target (file+head
                              ,pm/default-note-name-template
                              ,(pm/template-head-builder :prompt-for-tags t)))
                    ("d" "Basic note + tag prompt + alias prompt" plain
                     ,pm/note-basic-entry
                     :target (file+head
                              ,pm/default-note-name-template
                              ,(pm/template-head-builder :prompt-for-tags t :aliases `("%^{ALIAS}")))))
       :node node
       :props '(:unnarrowed t :empty-lines-before 1))
    (user-error "Node cannot be nil!")))
#+end_src

And then for capturing to existing notes, also giving the option of going to the note

#+begin_src emacs-lisp
(cl-defun pm/note-capture-existing (&key node)
  (interactive)
  (if node
      (org-roam-capture-
       :goto nil
       :info nil
       :keys nil
       :templates `(("a" "Edit note" plain
                     ,pm/note-basic-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder)))
                    ("b" "Edit note + goto" plain
                     ,pm/note-basic-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder))
                     :jump-to-captured t)
                    ("c" "Insert TODO" entry
                     ,pm/note-todo-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder))
                     :prepend t
                     :empty-lines 1)
                    ("d" "Insert TODO + goto" entry
                     ,pm/note-todo-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder))
                     :prepend t
                     :empty-lines 1
                     :jump-to-captured t)
                    ("e" "Insert IDEA" entry
                     ,pm/note-idea-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder))
                     :prepend t
                     :empty-lines 1)
                    ("f" "Insert IDEA + goto" entry
                     ,pm/note-idea-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder))
                     :prepend t
                     :empty-lines 1
                     :jump-to-captured t))
       :node node
       :props '(:unnarrowed t)) ;; 
    (user-error "Node cannot be nil!")))

#+end_src

Selection between templates is enshrined here:

#+begin_src emacs-lisp
(cl-defun pm/note-capture ()
  (interactive)
  (let ((node (pm/note-read)))
    (if (org-roam-node-file node)
        (pm/note-capture-existing :node node)
      (pm/note-capture-new :node node))))

(pm/leader
  "nc" '(pm/note-capture :which-key "capture note"))
#+end_src

**** Chores

Life notes are all encapsulated under a file ~chores.org~ as node headings. The purpose of this file is to capture daily administrative tasks which I have to do. 

#+begin_src emacs-lisp

(cl-defun pm/chore-capture ()
  (interactive)
  (let (
        (headings '("House" "Car" "Emails"))
        (node (org-roam-populate (org-roam-node-create :title "Chores"))))
    (org-roam-capture-
     :goto nil
     :info nil
     :keys nil
     :templates `(("a" "House" entry
                   ,pm/note-todo-entry
                   :target (file+head+olp
                            "chore.org"
                            ,(pm/template-head-builder
                              :tags '("chore")
                              :headings headings)
                            ,'("House")))
                  ("b" "Car" entry
                   ,pm/note-todo-entry
                   :target (file+head+olp
                            "chore.org"
                            ,(pm/template-head-builder
                              :tags '("chore")
                              :headings headings)
                            ,'("Car")))
                  ("c" "Emails" entry
                   ,pm/note-todo-entry
                   :target (file+head+olp
                            "chore.org"
                            ,(pm/template-head-builder
                              :tags '("chore")
                              :headings headings)
                            ,'("Emails"))))
     :node node
     :props '(:unnarrowed t))))


;; (cl-defun pm/project-capture ()
;;   (interactive)
;;   (let ((node (pm/project-read)))
;;     (if (org-roam-node-file node)
;;         (pm/project-capture-existing node)
;;       (pm/project-capture-new node))))

(pm/leader
  "nb" '(pm/chore-capture :which-key "capture chore"))

#+end_src

**** Links

#+begin_src emacs-lisp
(cl-defun pm/url-from-clipboard (callback)
  (let ((url (org-cliplink-clipboard-content)))
    (if (url-type (url-generic-parse-url url)) 
        (org-cliplink-retrieve-title
         url
         callback)
      (user-error "Malformed url: %s" url))))

(cl-defun pm/link-read (ref)
  "Takes a string ref and either directly returns a node if a match is found, else nil. If multiple found, prompts for user selection between all of them"
  (save-match-data
    (let (type path)
      (cond
       ((string-match org-link-plain-re ref)
        (setq type (match-string 1 ref)
              path (match-string 2 ref)))
       ((string-prefix-p "@" ref)
        (setq type "cite"
              path (substring ref 1))))
      (when (and type path)
        (let ((ids (org-roam-db-query
                    [:select [nodes:id]
                             :from nodes
                             :join refs
                             :on (= nodes:id refs:node-id)
                             :where (= refs:type $s1)
                             :and (= refs:ref $s2)
                             ]
                    type path)))
          (cond
           ((= (length ids) 0) nil)
           ((= (length ids) 1) (org-roam-populate (org-roam-node-create :id (car ids))))
           (t (pm/note-read
               :prompt (format "Select from notes with ref: \"%s\": " ref)
               :filter-fn (lambda (node)
                            (cl-some (lambda (id)
                                       (string= (car id) (org-roam-node-id node)))
                                     ids))))))))))

(cl-defun pm/link-capture-new (url title)
  (let ((node (org-roam-node-create :title title)))
    (org-roam-capture-
     :goto nil
     :info nil
     :keys nil
     :templates `(("a" "Basic Link note" plain
                   ,pm/note-basic-entry
                   :target (file+head
                            ,pm/default-note-name-template
                            ,(pm/template-head-builder
                              :tags `("link")
                              :refs `(,url))))
                  ("b" "Basic Link note + tag prompt" plain
                   ,pm/note-basic-entry
                   :target (file+head
                            ,pm/default-note-name-template
                            ,(pm/template-head-builder
                              :prompt-for-tags t
                              :tags `("link")
                              :refs `(,url))))
                  ("c" "Bookmarked Link note" plain
                   ,pm/note-basic-entry
                   :target (file+head
                            ,pm/default-note-name-template
                            ,(pm/template-head-builder
                              :tags `("link" "bookmark")
                              :refs `(,url))))
                  ("d" "Bookmarked Link note + tag prompt" plain
                   ,pm/note-basic-entry
                   :target (file+head
                            ,pm/default-note-name-template
                            ,(pm/template-head-builder
                              :prompt-for-tags t
                              :tags `("link" "bookmark")
                              :refs `(,url)))))
     :node node
     :props '(:unnarrowed t))))


(cl-defun pm/link-capture ()
  (interactive)
  (pm/url-from-clipboard
   (lambda (url title)
     (if-let ((node (pm/link-read url)))
         (org-roam-node-visit node)
       (pm/link-capture-new url title)))))

(pm/leader
  "nl" '(pm/link-capture :which-key "capture link"))
#+end_src

**** Projects

All projects will have the project tag

#+begin_src emacs-lisp
(cl-defun pm/project-read () 
  (pm/note-read
   :prompt "Select from projects: "
   :filter-fn (lambda (node)
                (cl-some (lambda (tag)
                           (string= tag "project"))
                         (org-roam-node-tags node)))))
(defun project-capture-templates ()
  `(("a" "Edit project" plain
     ,pm/note-basic-entry
     :target (file+head+olp
              ,pm/project-note-name-template
              ,(pm/template-head-builder
                :tags '("project")
                :headings '("Abstract" "Tasks" "Ideas" "Links" "Journal"))
              ,'("Abstract")))
    ("b" "Insert project todo" entry
     ,pm/note-todo-entry
     :target (file+head+olp
              ,pm/project-note-name-template
              ,(pm/template-head-builder
                :tags '("project")
                :headings '("Abstract" "Tasks" "Ideas" "Links" "Journal"))
              ,'("Tasks")))
    ("c" "Insert project idea" entry
     ,pm/note-idea-entry
     :target (file+head+olp
              ,pm/project-note-name-template
              ,(pm/template-head-builder
                :tags '("project")
                :headings '("Abstract" "Tasks" "Ideas" "Links" "Journal"))
              ,'("Ideas")))
    ("d" "Insert project link" item
     "%(org-cliplink-capture)"
     :target (file+head+olp
              ,pm/project-note-name-template
              ,(pm/template-head-builder
                :tags '("project")
                :headings '("Abstract" "Tasks" "Ideas" "Links" "Journal"))
              ,'("Links")))
    ("e" "Insert project journal" entry
     ,(pm/template-entry-builder :title-content (concat "[ " (pm/todays-date) " ]")
                                 :entry-content (concat "*** [ " (pm/current-time) " ]\n%?")
                                 :no-properties t
                                 :levels 2)
     :target (file+head+olp
              ,pm/project-note-name-template
              ,(pm/template-head-builder
                :tags '("project")
                :headings '("Abstract" "Tasks" "Ideas" "Links" "Journal"))
              ,'("Journal")))))

(cl-defun pm/project-capture-existing (node)
  (org-roam-capture-
   :goto nil
   :info nil
   :keys nil
   :node node
   :templates (project-capture-templates)
   :props '(:unnarrowed t :prepend t)))

(cl-defun pm/project-capture-new (node)
  (org-roam-capture-
   :goto nil
   :info nil
   :keys nil
   :templates `(("a" "Basic project note" plain
                 ,pm/note-basic-entry
                 :target (file+head+olp
                          ,pm/project-note-name-template
                          ,(pm/template-head-builder
                            :tags '("project")
                            :prompt-for-tags t
                            :headings '("Abstract" "Tasks" "Links" "Journal" "Ideas"))
                          ,'("Abstract"))))
   :node node
   :props '(:unnarrowed t :empty-lines 1)))

(cl-defun pm/project-capture ()
  (interactive)
  (if (file-directory-p (concat org-directory "/project"))
      nil
    (progn
      (make-directory (concat org-directory "/project"))))
  (let ((node (pm/project-read)))
    (if (org-roam-node-file node)
        (pm/project-capture-existing node)
      (pm/project-capture-new node))))

(pm/leader
  "np" '(pm/project-capture :which-key "capture project"))
#+end_src

**** Daily
**** Entities

People/Groups/Companies

Classification is an individual person or groups of people, possibly with multiple unique identifiers

*** Functions

**** intersperse

#+begin_src emacs-lisp :tangle ./functions.el
(defun pm/intersperse (lst value)
  "Intersperse LST with VALUE."
  (if (null lst)
      '()
    (let ((rest-of-list (cdr lst)))
      (if (null rest-of-list)
          lst
        (cons (car lst) (cons value (pm/intersperse rest-of-list value)))))))

#+end_src
**** list-to-org

#+begin_src emacs-lisp :tangle ./functions.el
(defun pm/list-to-org (lst &optional level)
  (unless level (setq level 1))
  (mapconcat (lambda (item)
               (if (listp item)
                   (pm/list-to-org item (1+ level))
                 (concat (make-string level ?*) " " item "\n\n")))
             lst
             ""))
#+end_src
**** list2str
#+begin_src emacs-lisp :tangle ./functions.el
(cl-defun pm/list2str (lst &key (between "") (before "") (after ""))
  (apply #'concat `(,before ,(apply #'concat (pm/intersperse (cl-remove-if-not 'stringp lst) between)) ,after)))
#+end_src
**** template-head-builder

#+begin_src emacs-lisp :tangle ./functions.el
(cl-defun pm/template-head-builder (&key (title "${title}")
                                         (tags `())
                                         (aliases `())
                                         (refs `())
                                         (headings `())
                                         (prompt-for-tags nil)
                                         (created "#+created_at: %U")
                                         (modified  "#+last_modified: %U"))
  "This function is the default builder for all note templates. It expects a series of keys and values in each case:
"
  (let
      ((file-tags (if (or
                       (> (length tags) 0)
                       prompt-for-tags)
                      (pm/list2str tags
                                   :before (concat "#+filetags: "
                                                   (if (> (length tags) 0) ":" ""))
                                   :after (concat (if (> (length tags) 0) ":" "")
                                                  (if prompt-for-tags "%^G" ""))
                                   :between ":")
                    nil))
       (properties (if (or
                        (> (length refs) 0)
                        (> (length aliases) 0))
                       (pm/list2str
                        `(,(when (> (length aliases) 0)
                             (pm/list2str aliases :between " " :before ":ROAM_ALIASES: " :after "\n"))
                          ,(when (> (length refs) 0)
                             (pm/list2str refs :between " " :before ":ROAM_REFS: " :after "\n")))
                        :before ":PROPERTIES:\n"
                        :after ":END:"
                        :between "\n")
                     nil))
       (olp (if (> (length headings) 0)
                (concat "\n" (pm/list-to-org headings))
              nil)))
    (pm/list2str `(,properties
                   ,(concat "#+title: " title)
                   ,created
                   ,modified
                   ,file-tags
                   ,olp
                   )
                 :between "\n")))
#+end_src
**** template-entry-builder

#+begin_src emacs-lisp :tangle ./functions.el
(cl-defun pm/template-entry-builder (&key (todo-state nil)
                                          (title-content nil)
                                          (entry-content nil)
                                          (levels 0)
                                          (tags `())
                                          (no-properties nil))
  (message todo-state)
  (let
      ((tag-str (if (> (length tags) 0)
                    (pm/list2str tags :between ":" :before " :" :after ":")
                  nil))
       (levels-str (if (> levels 0)
                       (make-string levels ?*)
                     nil)))
    (pm/list2str `(,(when (> levels 0) (pm/list2str `(,levels-str
                                                      ,todo-state
                                                      ,title-content
                                                      ,tag-str)
                                                    :between " "))
                   ,(unless no-properties ":PROPERTIES:\n:CREATED:  %U\n:END:")
                   ,(when entry-content entry-content))
                 :between "\n")))
#+end_src
**** time functions

#+begin_src emacs-lisp
(require 'ts)

(cl-defun pm/todays-date ()
  (let* ((now (ts-now))
         (day (ts-day now))
         (suffix (cond ((memq day '(11 12 13)) "th")
                       ((= 1 (% day 10)) "st")
                       ((= 2 (% day 10)) "nd")
                       ((= 3 (% day 10)) "rd")
                       (t "th"))))
    (concat (ts-day-name now)
            ", "
            (format "%s" (ts-day-of-month-num now))
            suffix
            " of "
            (format "%s" (ts-month-name now))
            " "
            (format "%s" (ts-year now))
            )))

(cl-defun pm/current-time ()
  (let* ((now (ts-now))
         (hour (ts-H now))
         (minute (ts-M now))
         (hour-formatted (if (< hour 10)
                             (format "0%s" hour)
                           (format "%s" hour)))
         (minute-formatted (if (< minute 10)
                             (format "0%s" minute)
                           (format "%s" minute))))
      (concat hour-formatted ":" minute-formatted)))


;; (pm/current-time)
#+end_src
** Agenda

*** Gather ~.org~ files relevant for agenda

We recurse everything under ~org-directory~

#+begin_src elisp
(setopt org-agenda-files (directory-files-recursively org-directory org-agenda-file-regexp))
#+end_src

*** Assign ~SPC o a~ as agenda menu

#+begin_src emacs-lisp
(defun pm/org-agenda-menu ()
  (interactive)
  (org-agenda))

(pm/leader
  "oa" '(pm/org-agenda-menu :which-key "agenda"))
#+end_src
*** Fix window

#+begin_src emacs-lisp
(setq org-agenda-restore-windows-after-quit t)
#+end_src
* Project Management

Manage projects using projectile

#+begin_src emacs-lisp
(require 'projectile)
(projectile-mode +1)

(add-to-list 'projectile-globally-ignored-directories "/nix/*")

(setq projectile-project-search-path
      '(
        "~/.config/emacs"
        "~/notes"
        ("~/code" . 4)))

(pm/leader
  "p" '(:ignore t :which-key "switch project")
  "pp" '(projectile-switch-project :which-key "switch project")
  "pf" '(projectile-find-file :which-key "find project file")
  "pb" '(projectile-switch-to-buffer :which-key "find project buffer")
  ;; ... add other projectile-specific bindings as needed
  )
(setq projectile-sort-order 'recentf)
(setq projectile-per-project-compilation-buffer t)
;; (use-package projectile  
;;   :straight t
;;   :diminish projectile-mode
;;   :config (projectile-mode)
;;   :custom ((projectile-completion-system 'ivy))
;;   :bind-keymap
;;   ("C-c p" . projectile-command-map)
;;   :init
;;   ;; NOTE: Set this to the folder where you keep your Git repos!
;;   (when (file-directory-p "~/code")
;;     (setq projectile-project-search-path '("~/code")))
;;   (setq projectile-switch-project-action #'projectile-dired))

;; (use-package counsel-projectile  
;;   :straight t
;;   :after projectile
;;   :config (counsel-projectile-mode))
#+end_src

* Completion System

In Emacs, a "completion system" refers to a mechanism that assists users by providing possible completions for a given partial input. This is especially useful in various contexts like typing commands, specifying file names, setting variable values, or even writing code. The completion system anticipates what the user intends to type next and offers suggestions to complete the input, making the interaction more efficient.

The completion system that is to be used is at the centre of any Emacs configuration as it lends itself to prescribing all the ways that user experience is defined. 

** Interfaces

In Emacs, a completion system's interface determines how candidates are presented to the user and how the user interacts with those candidates. Over the years, various interfaces have been developed, each with its own unique characteristics and interaction models. Many examples exist in different contexts:

- Minibuffer
- Vertical Lists
- Grid-based
- Buffer-based
- Popups
- Child Frames

*** Vertico

https://github.com/minad/vertico

Vertico is a minimalistic completion system for Emacs that provides a vertical interface for completion candidates. It stands out due to its simplicity and focus on doing one thing well: offering a streamlined vertical completion UI for the minibuffer. The focus of Vertico is to provide a UI which behaves correctly under all circumstances. By reusing the built-in facilities system, Vertico achieves full compatibility with built-in Emacs completion commands and completion tables. Vertico only provides the completion UI but aims to be highly flexible, extendable and modular.

#+begin_src emacs-lisp
(require 'vertico)
(vertico-mode)

;; Different scroll margin
(setq vertico-scroll-margin 0)

;; Show more candidates
(setq vertico-count 20)

;; Grow and shrink the Vertico minibuffer
(setq vertico-resize t)

;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
(setq vertico-cycle t)
#+end_src

*** Corfu

https://github.com/minad/corfu

Corfu (Completion Overlay Region FUnction) is an Emacs package that provides in-buffer completion using overlays, presenting completion candidates directly in the buffer akin to a popup. It's designed to offer a lightweight and straightforward completion experience. Corfu is a small package, which relies on the Emacs completion facilities and concentrates on providing a polished completion UI. In-buffer completion UIs in Emacs can hook into ~completion-in-region~, which implements the interaction with the user.

#+begin_src emacs-lisp
(require 'corfu)

(global-corfu-mode)
(setq corfu-auto t
      corfu-quit-no-match 'separator)

(setq completion-cycle-threshold 3)
(setq tab-always-indent 'complete)
#+end_src

** Matching and Filtering

In the context of Emacs, "Matching and Filtering" refers to the process of narrowing down a list of candidates based on user input, so that only those items that align with the input criteria remain visible or are presented to the user. This is especially useful in completion systems, where users might be presented with a large number of potential completions and need an efficient way to find the one they're looking for.

*** Orderless

https://github.com/oantolin/orderless

Orderless is an Emacs package that provides a flexible completion style for narrowing down candidates. Instead of requiring users to type the exact prefix or sequence of a candidate, Orderless allows for matching terms in any order, giving users a more relaxed and efficient completion experience.

#+begin_src emacs-lisp
(require 'orderless)
(setq completion-styles '(orderless basic)
      completion-category-overrides '((file (styles basic partial-completion))))
#+end_src

** Search & Navigation

One of the most important features in Emacs is being able to search and navigate such that users can quickly locate, move to, and manipulate text within and across files. There are a variety of features that users may intend to utilise:

- Incremental Search
- Regular Expression Search
- Multi-file Search
- Symbol and Semantic Search
- Buffer and Window Management
- Bookmarks
- History/Recent files
- Project Navigation
- Semantic Navigation

Typically in Emacs, there are a variety of internal and external methods to extend this functionality, typically as part of a generalised completion system and extend minibuffer actions and commands.

*** Consult

https://github.com/minad/consult

Consult (short for "CONtextualized Subcommands LightweighT") is an Emacs package that provides a collection of commands which use the minibuffer for display and completion. Consult enhances the Emacs minibuffer experience by providing a set of commands that offer richer displays, asynchronous operations, and seamless integration with modern completion systems. It's particularly useful for users looking to supercharge their minibuffer-based workflows in Emacs.

#+begin_src emacs-lisp
(require 'consult)
(require 'consult-projectile)
(require 'consult-org-roam)
(require 'consult-notes)
(require 'consult-dir)
#+end_src

** Annotations

Annotations refer to additional pieces of information displayed alongside completion candidates in the minibuffer. These annotations provide context, clarify the nature of the candidates, and help users make more informed selections.

*** Marginalia

https://github.com/minad/marginalia

Marginalia is an Emacs package designed to enhance the completion experience by providing rich annotations to candidates displayed in the minibuffer. When you're selecting from a list of items, Marginalia adds supplementary context and details to each item, helping you make more informed decisions.

#+begin_src emacs-lisp
(require 'marginalia)
(marginalia-mode)
#+end_src
** Actions

Actions refer to operations or commands that can be executed on a selected completion candidate. While the primary purpose of a completion system is to help users select from a list of candidates, often there's a need to perform different operations on these candidates beyond just selecting or inserting them. This is where actions come into play.

*** Embark

https://github.com/oantolin/embark

Embark is an Emacs package that enhances the interactive experience by providing context-specific actions (or "embarkations") on targets, which can be anything from minibuffer completion candidates to text selected in a buffer. Essentially, it allows users to take various actions on different types of data in a context-aware manner. It's not specifically tied to a completion system but is also used heavily there in combination with some of the already listed configuration.

#+begin_src emacs-lisp
(require 'embark)
(require 'embark-consult)

(general-define-key
 "C-." 'embark-act
 "C-;" 'embark-dwim
 "C-h B" 'embark-bindings)

;; Optionally replace the key help with a completing-read interface
(setq prefix-help-command #'embark-prefix-help-command)
;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
;; strategy, if you want to see the documentation from multiple providers.
(add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)


(add-to-list 'display-buffer-alist
             '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
               nil
               (window-parameters (mode-line-format . none))))

(add-hook 'embark-collect-mode-hook 'consult-preview-at-point-mode)
#+end_src

* Programming Languages
** General Configuration
*** Syntax Highlighting
**** Numbers

When programming highlight numbers

#+begin_src emacs-lisp
(require 'highlight-numbers)
(add-hook 'prog-mode-hook 'highlight-numbers-mode)
#+end_src

**** Bracket Delimiters

Add rainbow matching to all delimiters

#+begin_src emacs-lisp
(require 'rainbow-delimiters)
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
#+end_src

*** Line Numbers

List line-numbers by default and make it relative to cursor position

#+begin_src emacs-lisp
(column-number-mode)
(global-display-line-numbers-mode t)
(setq display-line-numbers 'relative)
#+end_src

Ensure a fixed width so that larger files don't interfere with the text in buffer alignment

#+begin_src emacs-lisp
(setq display-line-numbers-width-start t)
#+end_src

*** Bracket Delimiters

Especially useful for lisping

#+begin_src emacs-lisp
(require 'smartparens)
(add-hook 'prog-mode-hook 'smartparens-mode)
#+end_src
** Nix

Nix is a nice language

#+begin_src emacs-lisp
(require 'nix-mode)
(add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-mode))
#+end_src
** Elisp
* Utilities/Tools
** Profiling

~esup~, https://github.com/jschaf/esup is a tool used for profiling emacs startup time.

#+begin_src emacs-lisp
(require 'esup)
#+end_src

** Help

https://github.com/Wilfred/helpful

#+begin_src emacs-lisp
(require 'helpful)

(general-define-key
 "C-h f" 'helpful-function
 "C-h v" 'helpful-variable
 "C-h k" 'helpful-key)
#+end_src
* Functions

All functions here should be tangled into their own file, ~functions.el~ which can then be instantiated at the top of the generated ~config.el~. This will enforce that any function call can be referenced but keep the structure of this document intact.

** Reload Configuration
#+begin_src emacs-lisp ./functions.el
(defun pm/reload-config ()
  "Reloads the emacs configuration"
  (interactive)
  (load-file (concat user-emacs-directory "init.el")))
#+end_src
** Startup Time 

#+begin_src emacs-lisp :tangle ./functions.el
(defun display-startup-time ()
  (message "Emacs ready in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                    (time-subtract after-init-time before-init-time)))
           gcs-done))
#+end_src
* Finalizations

Here is configuration which should end up at the end of the tangled file

** Emacs Configuration Footer

All elisp files should end with this

#+begin_src emacs-lisp
(provide 'config.el)
;;; config.el ends here
#+end_src

#+begin_src emacs-lisp :tangle ./functions.el
(provide 'functions.el)
;;; functions.el ends here
#+end_src
