#+title: Emacs Configuration

This is my literate emacs confguration which I intend  to use for all of my computing needs.

* Notes
** TODOs
*** TODO Enable ~C-Enter~ in a list to create a new item in that list
Currently will only put a new org heading relative to the nearest one
https://github.com/alphapapa/unpackaged.el#org-return-dwim
*** TODO Text wrapping in org-mode documents
*** TODO Elisp linting and formatting
*** TODO org-mode code blocks indenting
*** TODO Add olivetti mode
*** TODO Set ~SPC u~ as the universal modifier
:PROPERTIES:
:CREATED:  [2023-10-21 Sat 19:19]
:END:
** IDEAs
*** IDEA Autoload all projects with .git
The idea is that all .git projects found under ~~/code~ or some other listed directory paths should be automatically listed. When searching through projects, the most recent edited or committed to should be listed first in that order
*** IDEA Set ~:EXPIRY:~ attribute when done to auto-archive finished todos
:PROPERTIES:
:ORDERED:  t
:CREATED:  <2023-10-13 Fri 14:35>
:END:

* Introduction
** TODO Explain purpose of this document

** Package Management

This is where this configuration differs from most others. Emacs has a wide variety of package management solutions, internally like ~package.el~ or externally like ~use-package~ or ~straight.el~. However, the problem persists is that any emacs configuration has implied external dependencies, say nodejs for writing javascript projects.  Where I differ is that I use Nix to manage both of the elisp package dependencies and the external dependencies. This is the general rule but a large exception is where software projects using Nix also maintain their own dependencies using shell hooks. This would also be a good idea to incorporate where a project buffer rationalises whethers the project is /"nixified"/ and if not will attempt to download those dependencies, or at least make the user aware that it is not available.  Not to digress, because the elisp packages are pre-installed, all that has to be done is to ~require~ them in a file and so removes a lot of unneccessary juggling of ~use-package~.

As this is a nixified emacs literate config, I use a flake to define an emacs package which contains all required dependencies. This may also be moved to inside my notes as externally referencing pieces of my configuration could be useful for blogging/research.

One pain point which may manifest is that the emacs-overlay which the flake uses becomes unmaintained or does not declare a package I want. A workaround could be to use ~straight.el~.

** Useful Links

- http://alhassy.com/emacs.d/index.html
- https://gitlab.com/public-repositories/emacs-groundup
- https://github.com/alphapapa/unpackaged.el
- http://honnef.co/articles/my-org-roam-workflows-for-taking-notes-and-writing-articles
- https://karelvo.com/blog/2023-02-17-orgmode
- https://www.sobyte.net/post/2022-05/emacs-package/
- https://www.brettwitty.net/exocortex.html
- https://github.com/technomancy/emacs-starter-kit  
- https://nullprogram.com/blog/2017/01/30/
- Prefer custom-set-variable(s) over setq https://emacs.stackexchange.com/questions/102/advantages-of-setting-variables-with-setq-instead-of-custom-el
- Similar to above, use setopt for emacs 29+ https://emacs.stackexchange.com/questions/78419/im-unsure-which-option-to-use-for-setting-a-variable-setq-customize-set-varia/78424#78424
- https://github.com/frap/emacs-literate
- Uses nix! https://panadestein.github.io/emacsd/
- https://github.com/caisah/emacs.dz
- https://github.com/alopezrivera/Seaman-Emacs/blob/main/seaman/seaman.org#base-configuration 
- https://emacsdocs.org/

* Prerequisites

Firstly, the configuration listed here should be executed first

** Emacs Configuration Header

Emacs has a [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html][convention]] which must be complied with when publishing elisp code.

#+begin_src emacs-lisp
;;; config.el --- Padraic's Emacs configuration -*- lexical-binding: t -*-

;; Copyright (C) 2023-2023 Patrick H Morris

;; Author: Patrick H Morris <patrick.morris.310@gmail.com>
;; Keywords: internal
;; URL: https://panadestein.github.io/emacsd/

;;; Commentary:
;; A fully fledged, reproducible Emacs configuration

;;; Code:
#+end_src

Note that this also specifies the usage of lexical binding. See https://nullprogram.com/blog/2016/12/22/ for an explaination. This should always be placed at the top of the file.

** Require locally defined functions

The function section places functions in a different file, ~functions.el~ which should be loaded at the start.

#+begin_src emacs-lisp
(load-file (concat user-emacs-directory "functions.el"))
#+end_src

** Disable Magic File Names on Startup

The ~file-name-handler-alist~ is a special variable containing lookup keys for handlers when accessing a particular file, it's not used at startup so we can disable it temporarily.

#+begin_src emacs-lisp
(defvar file-name-handler-alist-original file-name-handler-alist)
(setq file-name-handler-alist nil)
#+end_src

Restore it later using the ~emacs-startup-hook~

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (setq file-name-handler-alist file-name-handler-alist-original)))
  #+end_src

** Garbage Collection

We set the gc threshold to ~most-positive-fixnum~, which is the largest representable positive integer in elisp. Also increasing ~gc-cons-percentage~ increases memory usage before garbage collection.

#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.6)
#+end_src

Assign variable for the desired gc threshold

#+begin_src emacs-lisp
(defvar pm/gc-cons-threshold 100000000)
#+end_src

Reset gc once emacs has initialised

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook ; hook run after loading init files
          (lambda ()
            (setq gc-cons-threshold pm/gc-cons-threshold
                  gc-cons-percentage 0.1
                  file-name-handler-alist file-name-handler-alist-original)))
#+end_src

Ensure minibuffer operations are smooth

#+begin_src emacs-lisp
(add-hook 'minibuffer-setup-hook
          #'(lambda ()
              (setq gc-cons-threshold (* pm/gc-cons-threshold 2))))
(add-hook 'minibuffer-exit-hook
          #'(lambda ()
              (garbage-collect)
              (setq gc-cons-threshold pm/gc-cons-threshold)))
#+end_src

** Native Compilation

Check if native compilation is available for this emacs instance and if so configures native compilation settings and the path for where the compiled elisp files are stored which is the users emacs directory.

#+begin_src emacs-lisp
(when (and (fboundp 'native-comp-available-p) (native-comp-available-p))
  (progn
    (setq native-comp-async-report-warnings-errors nil)
    (setq native-comp-deferred-compilation t)
    (add-to-list 'native-comp-eln-load-path (expand-file-name "eln-cache/" user-emacs-directory))
    (setq package-native-compile t)))
#+end_src

This block might be unnecessary.

** Initialization Flag

This is a useful variable which can be used to mitigate issues surrounding reloading of the confi

#+begin_src emacs-lisp
(defvar pm/initialized nil)

(add-hook 'emacs-startup-hook
          #'(lambda ()
              (setq pm/initialized t)))
#+end_src

* Basic Emacs Settings

Modifications to the default emacs settings should exist here. No
external package should be referenced.

** Personal Configuration

Basic user information

#+begin_src emacs-lisp
(setq user-full-name "Patrick H Morris"
      user-mail-address "patrick.morris.310@gmail.com")
#+end_src 

** Init Files

Emacs has a variety of conventions of files which should be loaded and where certain configuration can exist. Anything related to that behaviour should go here

*** Default.el

This is quite important in context of how this emacs configuration is defined. This file may be used to generate a ~default.el~ file which is custom packaged with emacs. In such cases, having this setting be true would prevent that file from loading.

#+begin_src emacs-lisp
(setq inhibit-default-init t)
#+end_src

*** Custom.el

Define the custom file to exist within the user's emacs directory

#+begin_src emacs-lisp
(let ((customization-file
       (expand-file-name "custom.el" user-emacs-directory)))
  (unless (file-exists-p customization-file)
    (write-region "" nil customization-file))
  (setq custom-file customization-file)
  (load custom-file 'noerror))
#+end_src

https://panadestein.github.io/emacsd/#orgaf16e18

** Startup

Prevent the startup screen containing Emacs specific content/documentation/links

#+begin_src emacs-lisp
(setq inhibit-startup-message t)
#+end_src

Prevent the echo area startup message. ~inhibit-startup-echo-area-message~ has little to no affect, maybe for advertising reasons, either way the source of the message is in the function ~display-startup-echo-area-message~ which is overrided here in order to change the message.

#+begin_src emacs-lisp
(defun display-startup-echo-area-message ()
  (display-startup-time))
#+end_src

*** Initial Buffer

Decide what buffers should be opened by default. When customising emacs it is easiest to open this file and the messages buffer for any information

#+begin_src emacs-lisp
(setq initial-buffer-choice "~/.config/emacs/config.org")
#+end_src

**** TODO Define a sensible startup system

Maybe Agenda/Daily?

*** Scratch Buffer

Make the scratch buffer empty by default

#+begin_src emacs-lisp
(setq initial-scratch-message nil)
#+end_src

** File/Buffer/Text Behaviour

Configuration pertaining to global file behaviour should go here

*** Large File Warnings
Warn when opening files greater than 100MB

#+begin_src emacs-lisp
(setq large-file-warning-threshold 100000000)
#+end_src

*** Respect File Mutation

Should a file be modified outside of Emacs, always respect those changes. Also check for file changes every second, if this becomes an issue for performance, increase

#+begin_src emacs-lisp
(global-auto-revert-mode t)
(setq auto-revert-interval 1)
#+end_src

*** Always use UTF8

#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
#+end_src

*** Don't Make Backups

#+begin_src emacs-lisp
(setq make-backup-files nil)
#+end_src

*** End Sentence with Single Space

#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src
*** Don't save modified buffers on exit

If a buffer is "unsaved" when killing it, you will get an annoying prompt to save. If not saved, I want to just kill immediately

#+begin_src emacs-lisp
(defun pm/suppress-save-buffer-query-function ()
  (set-buffer-modified-p nil)
  t) ; Return t so other functions in kill-buffer-query-functions get called.

(add-to-list 'kill-buffer-query-functions 'pm/suppress-save-buffer-query-function)
#+end_src

** UI

*** Remove Features

Emacs by default comes with a clunky ugly interface, remove those features.

#+begin_src emacs-lisp
(scroll-bar-mode -1)
(tool-bar-mode -1)
(tooltip-mode -1)
(set-fringe-mode 10)
(menu-bar-mode -1)
#+end_src

*** Bell Modifications

Emacs comes with an audible bell sound when a user does someting erroneous. Having this be a visual feature is preferred.

#+begin_src emacs-lisp
(setq visible-bell t)
#+end_src

Disable it to be sure

#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src

*** Mitigate Blinking Cursor

#+begin_src emacs-lisp
(blink-cursor-mode -1)
#+end_src
*** Scrolling

#+begin_src emacs-lisp
(setq scroll-margin 0
      scroll-conservatively 100000
      scroll-preserve-screen-position 1)
#+end_src
** Y/N Prompt

Ensure all yes/no type queries can be answered with y/n

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src
** Debugging

Emacs enables debugging using the ~--debug-init~ flag. The configuration below increases the verbosity of warnings in such contexts.

#+begin_src emacs-lisp
(if init-file-debug
    (setq warning-minimum-level :debug)
  (setq warning-minimum-level :emergency))
#+end_src
** History

~savehist~ (short for "save history") is a built-in feature of Emacs that allows you to persistently save various history lists across Emacs sessions. This means that things like your command history, search history, and other similar histories can be remembered even after you close and restart Emacs.

#+begin_src emacs-lisp
(require 'savehist)
(savehist-mode)
#+end_src
** Littering

~no-littering~ sets sane defaults for a host of backup files etc that can build up

#+begin_src emacs-lisp
(require 'no-littering)
#+end_src

* Keybindings

It is better to define the keybinding system early as subsequent
functionality is dependent

** ~general.el~

~general~ is a keybinding framework for emacs and is complementary to evil mode users. ~SPC~ will be a global key to manage a lot of behaviour

#+begin_src emacs-lisp
(require 'general)
(general-evil-setup t)

(general-create-definer pm/leader
  :keymaps '(normal insert visual emacs)
  :prefix "SPC"
  :global-prefix "C-SPC")
#+end_src

** ~which-key~

~which-key~ enhances the Emacs experience by providing real-time, interactive feedback on keybindings, making it easier to navigate and use the vast array of commands and functionalities available in the editor.

#+begin_src emacs-lisp
(require 'which-key)
(which-key-mode)
(setq which-key-idle-delay 0)
#+end_src
** Global Keybindings

Here is a space for defining all global keybindings

*** Bucket

For keybindings which haven't found their place in the config.

#+begin_src emacs-lisp
(pm/leader
  "r" '(pm/reload-config :which-key "Reload config")
  "u" '(:ignore t :which-key "ui")
  "ut" '(counsel-load-theme :which-key "Select Theme"))
#+end_src

*** Esc Acts as Quit

By default, ~C-g~ will quit a process which is slightly more work than ~<escape>~

#+begin_src emacs-lisp
(general-define-key
 "<escape>" 'keyboard-escape-quit)
#+end_src

* Display

Configuration regarding the emacs appearence should go here

** Theme

doom-themes is a popular collection of emacs themes. 

#+begin_src emacs-lisp
(require 'doom-themes)
(setq doom-themes-enable-bold t    
      doom-themes-enable-italic t)

(unless pm/initialized (load-theme 'doom-nord-aurora t)) 
(doom-themes-visual-bell-config)
(doom-themes-org-config)
#+end_src
** Font

Iosevka is a nice font

#+begin_src emacs-lisp
(set-face-attribute 'default nil :font "Iosevka Comfy Fixed" :height 100)
#+end_src 

** Icons

#+begin_src emacs-lisp
(require 'all-the-icons)
#+end_src

** Modeline

Also borrowing from the doom collection

#+begin_src emacs-lisp
(require 'doom-modeline)
(doom-modeline-mode t)
(setq doom-modeline-height 55)
(setq doom-modeline-buffer-file-name-style 'relative-to-project)
(setq doom-line-numbers-style 'relative)
(setq doom-modeline-major-mode-icon t)
(setq doom-modeline-buffer-state-icon t)
(setq doom-modeline-major-mode-color-icon t)
(setq doom-modeline-window-width-limit nil)
#+end_src
** Windows
*** Fringe

The "fringe" is the narrow vertical areas on either side of windows

#+begin_src elisp
(set-fringe-mode 0)
#+end_src
*** Winner

#+begin_src elisp
(require 'winner)
(winner-mode t)
#+end_src
*** Selection

#+begin_src emacs-lisp
(require 'ace-window)
(setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
#+end_src
* Editing

File editing is the most important thing an editor does right?!?!

** Text Behaviour
*** Long Lines

Emacs has historically had severe performance issues with files that contain long lines.

#+begin_src emacs-lisp
(require 'so-long)
#+end_src

Add the global mode once initialisation has finished as it 

#+begin_src emacs-lisp
(add-hook 'after-init-hook 'global-so-long-mode)
#+end_src

*** Filling/Wrapping

Define a variable to be used to specify column width

"Filling" refers to the process of breaking lines of text to fit within a specified width, which is typically the value of the ~fill-column~ variable. This action ensures that text is neatly wrapped and presented within the confines of a set width, making it more readable and visually organized, especially in text modes.

#+begin_src emacs-lisp
(setq fill-column 80)
#+end_src

It is probably not desirable to fill unless the user specifies directly. Enabling visual line wrapping is preferable as it does not alter the file in order to make the editing experience more appealing. The desired effect can be achieved using ~visual-line-mode~ which wraps text which goes past a certain point but maintains the same line. "Filling" can be opted in using one of the many commands like ~evil-fill~ 

Wrapping is where text is shown on the same line but the pane width is respected such that the line "wraps" around the screen. ~visual-line-mode~ is a minor mode in Emacs that affects how lines of text are displayed in the buffer, without modifying the actual content of the file. When this mode is enabled, long lines of text are visually wrapped at the edge of the window, making them appear as multiple lines on the screen, even though they remain a single line in the file.

We only want to turn this on for text and programming modes as things like the minibuffer and terminals should not need to do this

#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'visual-line-mode)
(add-hook 'prog-mode-hook 'visual-line-mode)
#+end_src

However, ~visual-line-mode~ will wrap only at the window edge which could mean arbitrarily long lines if the window is the full screen width. Alternatively, using ~visual-fill-column~ package allows for soft wrapping at a specific column which is referenced by ~pm/column-width~. This should make text wrapping occur at that column width or if the pane is smaller. This should make for a better reading experience.

https://codeberg.org/joostkremers/visual-fill-column

Here, I've increased the column width as the default ~fill-column~ is too narrow at 80. Most programming modes ought to provide their own prettification tooling which should override any text wrapping. "Filling" can be left manual and only used when align code commentary or things of that ilk.

#+begin_src emacs-lisp
(require 'visual-fill-column)
(add-hook 'visual-line-mode-hook
          #'(lambda ()
              (setq visual-fill-column-width 140) 
              (visual-fill-column-mode)))
#+end_src

https://github.com/seagle0128/doom-modeline/issues/672

Always ensure that the modeline is aligned as far right
#+begin_src emacs-lisp
(setq mode-line-right-align-edge 'right-fringe)
#+end_src

*** Tabs vs Spaces

Don't trust tabs

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq tab-width 2)
#+end_src

The tab-always-indent variable essentially allows users to configure a balance between indentation and completion behaviors, based on their preferences and workflow. Some users prefer the TAB key to prioritize indentation, while others might want it to emphasize completion, especially in modes or contexts where completion is frequently used.

When ~tab-always-indent~ is set to ~complete~, pressing TAB will first try to indent the current line. If the line is already correctly indented, or if the point isn't at the beginning of a line, Emacs will then try to perform completion.

#+begin_src emacs-lisp
(setq-default tab-always-indent 'complete)
#+end_src

** ~evil~

For those who like to use vim in emacs

#+begin_src emacs-lisp
(setq evil-want-integration t)
(setq evil-want-keybinding nil)
(setq evil-want-C-u-scroll t)
(setq evil-want-C-i-jump nil)
(setq evil-undo-system 'undo-tree)

(require 'evil)
(evil-mode 1)

(require 'evil-collection)
(evil-collection-init)

(evil-set-initial-state 'messages-buffer-mode 'normal)
(evil-set-initial-state 'dashboard-mode 'normal)
#+end_src

#+begin_src emacs-lisp
(general-def 'evil-insert-state-map
  "C-g" 'evil-normal-state
  "C-h" 'evil-delete-backward-char-and-join)

(general-define-key 
 :states 'motion
 "j" 'evil-next-visual-line
 "k" 'evil-previous-visual-line)
#+end_src

** ~undo-tree~

A very nice visualisation tool for tracing file changes in a tree hierarchy

#+begin_src emacs-lisp
(require 'undo-tree)
(general-define-key
 "C-x u" 'undo-tree-visualize)

(global-undo-tree-mode)
(setq undo-tree-visualizer-timestamps t)
(setq undo-tree-visualizer-diff t)
(setq undo-tree-show-help-in-visualize-buffer t)
(setq undo-tree-auto-save-history t)
(setq undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "undo"))))
#+end_src

* Git
** ~magit~

The best git gui ever made

#+begin_src emacs-lisp
(require 'magit)
(setopt magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1) ; What does this do?
#+end_src

#+begin_src emacs-lisp
(pm/leader
  "m" '(:ignore t :which-key "magit")
  "mm" '(magit-status :which-key "status"))
#+end_src
* Org

/Org/ is a versatile and powerful mode in Emacs designed for keeping notes, maintaining to-do lists, planning projects, and authoring documents. It's built around a plain-text formatting system, making it platform-independent and easily readable outside of Emacs. Over the years, /Org/ has evolved into a robust toolset that can handle everything from personal task management to publishing, coding, and even scientific research.

#+begin_src emacs-lisp
(require 'org)
#+end_src

Also create a general.el keybind for org mode contexts

#+begin_src emacs-lisp
(pm/leader
  "o" '(:ignore t :which-key "org"))
#+end_src

** Appearence and Behaviour

*** Ellipsis

Replaces the default content marker, "⋯", with a nice unicode arrow.

#+begin_src emacs-lisp
(setq org-ellipsis " ⤵")
#+end_src

*** Bullets

/Org-bullets/ is an Emacs package designed to enhance the visual appearance of Org-mode documents by replacing the standard asterisks (*) used for headlines with more visually appealing bullet characters.

#+begin_src emacs-lisp
(require 'org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+end_src

*** Indentation

Content under org headings will be indented such that it is clear under which heading content is nested.

#+begin_src emacs-lisp
(setq org-startup-indented t)
(add-hook 'org-mode-hook 'org-indent-mode)
#+end_src

*** Markers

Markers relate to the markup syntax used to provide different kinds of text styling.

#+begin_src emacs-lisp
(setq org-hide-emphasis-markers t)
#+end_src

**** TODO Add a font which works well with the different kinds of syntax highlighting

*** Code Blocks

In Org mode within Emacs, code blocks (often referred to as "source blocks") allow for the inclusion of source code from various programming languages. These blocks can be used for documentation, literate programming, or for dynamically generating content within an Org document.

One of the powerful features of source blocks in Org mode is that they can be executed. By placing the cursor within a source block and pressing C-c C-c, you can run the code if Emacs is configured to support that particular language. The results can be inserted directly into the Org document.

**** Template Tab Completion

Since org-mode 9.2, the completion ~<s TAB~ does not work out of the box and so org-tempo is required

Also adds the completion for elisp source code blocks using ~<el TAB~

#+begin_src emacs-lisp
(require 'org-tempo)
(add-to-list 'org-structure-template-alist
             '("el" . "src emacs-lisp"))
#+end_src

**** Indentation

Ensures that source code blocks are aligned with the left-most column.

#+begin_src emacs-lisp
(setq org-src-preserve-indentation t)
#+end_src

Make Tab respect indentation of the major mode for the lang

#+begin_src emacs-lisp
(setq org-src-tab-acts-natively t)
#+end_src

**** Evaluation

Don't ask permission to evaluate. Evaluation can be done using the Keybinding ~C-c C-c.~

#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src

*** Folding

Fold headings at start

#+begin_src emacs-lisp
(setq org-startup-folded t)
#+end_src

*** Timestamp

We always want to record for each org file when it was last edited

#+begin_src emacs-lisp
(require 'time-stamp)

(setq time-stamp-active t)
(setq time-stamp-start "#\\+last_modified:[ \t]")
(setq time-stamp-end "$")
(setq time-stamp-format "\[%Y-%m-%d %a %H:%M\]")

(add-hook 'before-save-hook #'time-stamp)
#+end_src

*** Links

Naked urls are fine but it is preferred to use ~org-cliplink~ as a way to gather extra info

#+begin_src emacs-lisp
(require 'org-cliplink)
#+end_src

*** Graphs

#+begin_src emacs-lisp
(setq ob-mermaid-cli-path (getenv "MERMAID_CLI"))
(add-to-list 'org-babel-load-languages '(mermaid . t))

(add-to-list 'org-structure-template-alist
             '("mrm" . "src mermaid :file /tmp/test.png"))
#+end_src

**** TODO Add inline images for  working!!
*** Miscellaneous

Prevents edits to content hidden under a folded heading

#+begin_src emacs-lisp
(setq org-catch-invisible-edits t)
#+end_src

** Tasks

Org mode in Emacs for task management is a powerful way to organize, prioritize, and track tasks and projects. The flexibility of Org mode allows users to create a system tailored to their unique needs.

*** ~TODO~ States

By default, org mode provides two states, ~TODO~ and ~DONE~ which are used to describe and manage a task. The below keyword states provide a base outline on how tasks are defined and managed across the duration of their lifetime.

Extending this behaviour we can add more states which offer a generic way of tracking any arbitrary task.

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence
         "TODO(t)" ;; A task that needs doing and is ready to do
         "PROG(p!)" ;; A task that is in progress
         "NEXT(n!)" ;; A task which should be done next
         "WAIT(w@/!)" ;; A task which is held up for an external reason
         "HOLD(h@/!)" ;; A task which is paused
         "|" ;;
         "DONE(d!)" ;; When a task is completed
         "KILL(k@/!)" ;; When a task is rejected
         "FAIL(f@/!)" ;; When a task is failed
         )
        (sequence
         "NOTE" ;; Not necessary for agenda, just for highlighting in places
         "LINK" ;; A naked url which is to be changed to a link note
         "IDEA" ;; A piece of information which might manifest into something
         "|")))
#+end_src

It is to be noted that TODO states can be defined per-file, which may come in handy for prescribing behaviour for certain notes/documents.

#+begin_src emacs-lisp
(setq org-log-done 'note)
(setq org-log-into-drawer t) 
#+end_src

*** Block ~DONE~ state for TODOs with dependent children TODOs

Should a TODO heading contain nested TODOs, then all nested TODOs must be put in a finished state

#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
#+end_src

*** Create custom hook which for ~org-insert-todo-heading~

As org-mode does not come with a hook for ~org-insert-todo-heading~ we want to add one for lines beginning

#+begin_src emacs-lisp
(defun pm/run-org-insert-todo-heading-hook (&rest _)
  "Run `pm/org-insert-todo-heading-hook'."
  (run-hooks 'pm/org-insert-todo-heading-hook))

(advice-add 'org-insert-todo-heading :after 'pm/run-org-insert-todo-heading-hook)
(advice-add 'org-insert-todo-heading-respect-content :after 'pm/run-org-insert-todo-heading-hook)
(advice-add 'org-insert-todo-subheading :after 'pm/run-org-insert-todo-heading-hook)

;; (add-hook 'org-after-todo-state-change-hook #'my/log-todo-creation-date)
#+end_src

#+begin_src emacs-lisp
(setopt org-insert-heading-respect-content t)
(setopt org-insert-todo-heading-respect-content t)
#+end_src

*** ~CREATED~ metadata timestamp

For any ~TODO~ heading, a ~SCHEDULED~ or ~DEADLINE~  and ~CLOSED~ timestamp metadata can be assigned. This is useful metadata but also including ~CREATED~ would be useful.

We define the 4 timestamp kinds:

And then add a specialised function always adds a ~CREATED~ timestamp property. 

#+begin_src emacs-lisp
(require 'org-expiry)

(defun pm/org-add-created-timestamp ()
  (save-excursion
    (org-back-to-heading)
    (org-set-property "CREATED"
                      (format-time-string
                       (org-time-stamp-format 'long 'inactive)
                       (org-current-time)))))

(add-hook 'pm/org-insert-todo-heading-hook 'pm/org-add-created-timestamp) 
#+end_src
*** Add ~ORDERED~ property for any TODO heading

The ~ORDERED~ property restricts sequential TODO's under a heading to be assigned as ~DONE~ until the previous ~TODO~ is. This enforces that tasks and subtasks are described in the order they are to be completed. 

#+begin_src emacs-lisp
;; (defun pm/org-todo-heading-add-ordered-property ()
;;   (when (org-at-heading-p)
;;     (org-set-property "ORDERED" "t")))

;; (add-hook 'pm/org-insert-todo-heading-hook 'pm/org-todo-heading-add-ordered-property)
#+end_src

** Notes
*** Initialisation

#+begin_src emacs-lisp
(require 'org-roam)
(setopt org-directory "~/notes"
        org-roam-directory org-directory
        org-roam-dailies-directory "daily/")
(setq org-roam-database-connector 'sqlite-builtin)
(org-roam-db-autosync-mode)


(pm/leader
  "n" '(:ignore t :which-key "notes"))
#+end_src

#+begin_src emacs-lisp
(defun pm/return-t (orig-fun &rest args) t)
(defun pm/disable-yornp (orig-fun &rest args)
  (advice-add 'yes-or-no-p :around #'pm/return-t)
  (advice-add 'y-or-n-p :around #'pm/return-t)
  (let ((res (apply orig-fun args)))
    (advice-remove 'yes-or-no-p #'pm/return-t)
    (advice-remove 'y-or-n-p #'pm/return-t)
    res))
(advice-add 'org-roam-capture--finalize :around #'pm/disable-yornp)

#+end_src
*** Display

#+begin_src emacs-lisp
(defun pm/rpartial (fn &rest args)
  "Return a partial application of FUN to right-hand ARGS.

ARGS is a list of the last N arguments to pass to FUN. The result is a new
function which does the same as FUN, except that the last N arguments are fixed
at the values with which this function was called."
  (declare (side-effect-free t))
  (lambda (&rest pre-args)
    (apply fn (append pre-args args))))

(cl-defmethod org-roam-node-pm/filetitle ((node org-roam-node))
  "Return the value of \"#+title:\" (if any) from file that NODE resides in.
If there's no file-level title in the file, return empty string."
  (or (if (= (org-roam-node-level node) 0)
          (org-roam-node-title node)
        (org-roam-node-file-title node))
      ""))

(cl-defmethod org-roam-node-pm/hierarchy ((node org-roam-node))
  "Return hierarchy for NODE, constructed of its file title, OLP and direct title.
If some elements are missing, they will be stripped out."
  (let ((title     (org-roam-node-title node))
        (olp       (org-roam-node-olp   node))
        (level     (org-roam-node-level node))
        (filetitle (org-roam-node-pm/filetitle node))
        (separator (propertize "<>" 'face 'shadow)))
    (cl-case level
      ;; node is a top-level file
      (0 filetitle)
      ;; node is a level 1 heading
      (1 (concat (propertize filetitle 'face '(shadow italic))
                 separator title))
      ;; node is a heading with an arbitrary outline path
      (t (concat (propertize filetitle 'face '(shadow italic))
                 separator (propertize (string-join olp separator) 'face '(shadow italic))
                 separator title)))))

(cl-defmethod org-roam-node-pm/type ((node org-roam-node))
  "Return the directory relative to `org-roam-directory' as a note's \"type\"."
  (when-let (dir (thread-first
                   node
                   (org-roam-node-file)
                   (file-relative-name org-roam-directory)
                   (file-name-directory)))
    (directory-file-name dir)))

(cl-defmethod org-roam-node-pm/tags ((node org-roam-node))
  "Return tags formatted in the same way how they appear in org files."
  (cl-remove-if (pm/rpartial
                 #'member (delq
                           nil (append
                                (list (bound-and-true-p org-archive-tag)
                                      (bound-and-true-p org-attach-auto-tag))
                                (bound-and-true-p org-num-skip-tags))))
                (org-roam-node-tags node)))

(setq org-roam-node-display-template
      (format "${pm/hierarchy:*} %s %s"
              (propertize "${pm/type}" 'face 'font-lock-keyword-face)
              (propertize "${pm/tags:*}" 'face '(:inherit org-tag :box nil))))

(add-to-list 'org-roam-node-template-prefixes '("pm/tags" . "#"))
(add-to-list 'org-roam-node-template-prefixes '("pm/type" . "@"))
#+end_src
*** Templates
**** Entries

***** Basic Entry

#+begin_src emacs-lisp
(defvar pm/note-basic-entry (pm/template-entry-builder :entry-content "%?" :no-properties t))
#+end_src
***** Todo Entry


#+begin_src emacs-lisp
(defvar pm/note-todo-entry (pm/template-entry-builder :todo-state "TODO" :levels 2 :title-content "%?"))
#+end_src

***** Journal Entry

#+begin_src emacs-lisp
(defvar pm/note-journal-entry (pm/template-entry-builder :title-content "[%<%T>]\n %?" :levels 2 :no-properties t))
#+end_src

***** Idea Entry

#+begin_src emacs-lisp
(defvar pm/note-idea-entry (pm/template-entry-builder :todo-state "IDEA" :levels 2 :title-content "%?"))
#+end_src

***** Link Entry (From Clipboard)

#+begin_src emacs-lisp
(defvar pm/note-link-entry (pm/template-entry-builder
                            :todo-state "LINK"
                            :levels 2
                            :title-content "%(org-cliplink-capture)"
                            :tags '("link")))
#+end_src
**** Names

***** Default

#+begin_src emacs-lisp
(defvar pm/default-note-name-template "%<%s>__${slug}.org")
#+end_src

***** Project

#+begin_src emacs-lisp
(defvar pm/project-note-name-template "project/${slug}.org")
#+end_src

***** Daily

#+begin_src emacs-lisp
(defvar pm/daily-note-name-template "%<%Y-%m-%d>.org")
#+end_src

***** Person

#+begin_src emacs-lisp
(defvar pm/people-note-name-template "people/<%s>__${slug}.org")
#+end_src
**** Targets

***** Basic

#+begin_src emacs-lisp
(defvar pm/basic-note-target `(file+head ,pm/default-note-name-template ,(pm/template-head-builder)))
#+end_src

***** Action

#+begin_src emacs-lisp
(defvar pm/action-note-target
  `(file+head
    ,pm/default-note-name-template
    ,(pm/template-head-builder
      :headings '("Journal" "Tasks" "Ideas" "Links")
      )))
#+end_src
**** Generic
***** Basic Note Template
#+begin_src emacs-lisp
(defvar pm/basic-note-template
  `("d" "" plain
    pm/note-basic-entry
    :target ,pm/basic-note-target
    :unnarrowed t
    :empty-lines-before 1))
#+end_src
*** Finding
**** Prompt

#+begin_src emacs-lisp
(defvar pm/note-find-prompt "<[Note]> ")
#+end_src
**** Leader key

#+begin_src emacs-lisp
(pm/leader
  "nf" '(:ignore t :which-key "find notes"))
#+end_src

**** Find matching note

Default org-roam has awkward fallback process when finding notes. If a note does not exist, it will immediately go into a capture process which is not exactly desired

#+begin_src emacs-lisp
(cl-defun pm/note-read (&key (initial-input nil)
                             (filter-fn nil)
                             (sort-fn nil)
                             (require-match nil)
                             (prompt pm/note-find-prompt))
  (org-roam-node-read initial-input filter-fn sort-fn require-match prompt))

(cl-defun pm/note-find ()
  (interactive)
  (org-roam-node-visit (pm/note-read :require-match t) t))

(pm/leader
  "nf" '(pm/note-find :which-key "find note"))
#+end_src

**** TODO Find note by tag(s)
**** TODO Find project notes
**** TODO Find people notes
**** TODO Find link notes
**** TODO Find daily notes
*** TODO Searching
*** Capturing

Capturing is the central component to how the note system should work. Ideally, the flow should work as a way to automate editing or creation of notes in a simple form. 

**** Generic

A generic note is self-explanatory, just a basic unopinionated note type. As mentioned, there is two approaches, creating new notes and editing of currently existing notes. For capturing new notes:

#+begin_src emacs-lisp
(cl-defun pm/note-capture-new (&key node)
  (interactive)
  (if node
      (org-roam-capture-
       :goto nil
       :info nil
       :keys nil
       :templates `(("a" "Basic note" plain
                     ,pm/note-basic-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder)))
                    ("b" "Basic note + alias prompt" plain
                     ,pm/note-basic-entry
                     :target (file+head
                              ,pm/default-note-name-template
                              ,(pm/template-head-builder :aliases `("%^{ALIAS}"))))
                    ("c" "Basic note + tag prompt" plain
                     ,pm/note-basic-entry
                     :target (file+head
                              ,pm/default-note-name-template
                              ,(pm/template-head-builder :prompt-for-tags t)))
                    ("d" "Basic note + tag prompt + alias prompt" plain
                     ,pm/note-basic-entry
                     :target (file+head
                              ,pm/default-note-name-template
                              ,(pm/template-head-builder :prompt-for-tags t :aliases `("%^{ALIAS}")))))
       :node node
       :props '(:unnarrowed t :empty-lines-before 1))
    (user-error "Node cannot be nil!")))
#+end_src

And then for capturing to existing notes, also giving the option of going to the note

#+begin_src emacs-lisp
(cl-defun pm/note-capture-existing (&key node)
  (interactive)
  (if node
      (org-roam-capture-
       :goto nil
       :info nil
       :keys nil
       :templates `(("a" "Edit note" plain
                     ,pm/note-basic-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder)))
                    ("b" "Edit note + goto" plain
                     ,pm/note-basic-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder))
                     :jump-to-captured t)
                    ("c" "Insert TODO" entry
                     ,pm/note-todo-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder))
                     :prepend t
                     :empty-lines 1)
                    ("d" "Insert TODO + goto" entry
                     ,pm/note-todo-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder))
                     :prepend t
                     :empty-lines 1
                     :jump-to-captured t)
                    ("e" "Insert IDEA" entry
                     ,pm/note-idea-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder))
                     :prepend t
                     :empty-lines 1)
                    ("f" "Insert IDEA + goto" entry
                     ,pm/note-idea-entry
                     :target (file+head ,pm/default-note-name-template ,(pm/template-head-builder))
                     :prepend t
                     :empty-lines 1
                     :jump-to-captured t))
       :node node
       :props '(:unnarrowed t)) ;; 
    (user-error "Node cannot be nil!")))

#+end_src

Selection between templates is enshrined here:

#+begin_src emacs-lisp
(cl-defun pm/note-capture ()
  (interactive)
  (let ((node (pm/note-read)))
    (if (org-roam-node-file node)
        (pm/note-capture-existing :node node)
      (pm/note-capture-new :node node))))

(pm/leader
  "nc" '(pm/note-capture :which-key "capture note"))
#+end_src

**** Links

Link notes are the centre of the notetaking system, they intrinsically orientate content from the outside world into my notes. There are a few ideas I want to get across

- The basic link note contains just a url reference using the ~ROAM_REFS~ property list. The title is extracted utilising ~org-cliplink~ to download the url's html content and extract the content from the ~<title>~ tag.
- As a link note integrates with outside material, functionality can be built on the basis of identifying links by either properties or tags or even automatic generation of links to other notes
  - E.g For a youtube video or a github repo which would be a common enough entry in my flow, the youtube channel or github organisation could also be created.
    - A tag for youtube or github may apply for the link note
    - A url property should also be included
  - Another actionable idea is including a bookmark tag which can be used to mark link notes which I regularly interact with
    - Using ~org-ql~ or other custom functionality, it should be possible to create a bookmarking tool using ~rofi~ to search through those links
    - The same idea can apply to searching through link notes in general
    - A simple tree like structure could work as it multiple links can exist for a single note
- However, a link note should not be generally thought of as being 1-of-1 with a url
  - A good example is ~org-roam~, it has references to its website url, its github repo and it's discourse
  - Many such cases exist like this, especially in a software context
  - A generic link capture template should always add a url to ~ROAM_REFS~ which enables easier lookup
- A note should be transformed iteratively by the issuance of capture templates
  - The creation of a note ~org-roam~ containing no tags
  - A link capture of that note to include a ref using the url and a tag link
  - A github link capture of that note to add another ref and github
  
#+begin_src emacs-lisp
(cl-defun pm/url-from-clipboard (callback)
  (let ((url (org-cliplink-clipboard-content)))
    (if (url-type (url-generic-parse-url url)) 
        (org-cliplink-retrieve-title
         url
         callback)
      (user-error "Malformed url: %s" url))))

(cl-defun pm/link-read (ref)
  "Takes a string ref and either directly returns a node if a match is found, else nil. If multiple found, prompts for user selection between all of them"
  (save-match-data
    (let (type path)
      (cond
       ((string-match org-link-plain-re ref)
        (setq type (match-string 1 ref)
              path (match-string 2 ref)))
       ((string-prefix-p "@" ref)
        (setq type "cite"
              path (substring ref 1))))
      (when (and type path)
        (let ((ids (org-roam-db-query
                    [:select [nodes:id]
                             :from nodes
                             :join refs
                             :on (= nodes:id refs:node-id)
                             :where (= refs:type $s1)
                             :and (= refs:ref $s2)
                             ]
                    type path)))
          (cond
           ((= (length ids) 0) nil)
           ((= (length ids) 1) (org-roam-populate (org-roam-node-create :id (car ids))))
           (t (pm/note-read
               :prompt (format "Select from notes with ref: \"%s\": " ref)
               :filter-fn (lambda (node)
                            (cl-some (lambda (id)
                                       (string= (car id) (org-roam-node-id node)))
                                     ids))))))))))

(cl-defun pm/link-capture-new (url title)
  (let ((node (org-roam-node-create :title title)))
    (org-roam-capture-
     :goto nil
     :info nil
     :keys nil
     :templates `(("a" "Basic Link note" plain
                   ,pm/note-basic-entry
                   :target (file+head
                            ,pm/default-note-name-template
                            ,(pm/template-head-builder
                              :tags `("link")
                              :refs `(,url))))
                  ("b" "Basic Link note + tag prompt" plain
                   ,pm/note-basic-entry
                   :target (file+head
                            ,pm/default-note-name-template
                            ,(pm/template-head-builder
                              :prompt-for-tags t
                              :tags `("link")
                              :refs `(,url))))
                  ("c" "Bookmarked Link note" plain
                   ,pm/note-basic-entry
                   :target (file+head
                            ,pm/default-note-name-template
                            ,(pm/template-head-builder
                              :tags `("link" "bookmark")
                              :refs `(,url))))
                  ("d" "Bookmarked Link note + tag prompt" plain
                   ,pm/note-basic-entry
                   :target (file+head
                            ,pm/default-note-name-template
                            ,(pm/template-head-builder
                              :prompt-for-tags t
                              :tags `("link" "bookmark")
                              :refs `(,url)))))
     :node node
     :props '(:unnarrowed t))))


(cl-defun pm/link-capture ()
  (interactive)
  (pm/url-from-clipboard
   (lambda (url title)
     (if-let ((node (pm/link-read url)))
         (org-roam-node-visit node)
       (pm/link-capture-new url title)))))

(pm/leader
  "nl" '(pm/link-capture :which-key "capture link"))
#+end_src

**** Projects

All projects will have the project tag

#+begin_src emacs-lisp
(cl-defun pm/project-read () 
  (pm/note-read
   :prompt "Select from projects: "
   :filter-fn (lambda (node)
                (cl-some (lambda (tag)
                           (string= tag "project"))
                         (org-roam-node-tags node)))))

(cl-defun pm/project-capture-existing (node)
  (org-roam-capture-
   :goto nil
   :info nil
   :keys nil
   :templates `(("a" "Edit project" plain
                 ,pm/note-basic-entry
                 :target (file+head+olp
                          ,pm/project-note-name-template
                          ,(pm/template-head-builder
                            :tags '("project")
                            :headings '("Abstract" "Tasks" "Ideas"))
                          ,'("Abstract")))
                ("b" "Insert project todo" plain
                 ,pm/note-todo-entry
                 :target (file+head+olp
                          ,pm/project-note-name-template
                          ,(pm/template-head-builder
                            :tags '("project")
                            :headings '("Abstract" "Tasks" "Ideas"))
                          ,'("Tasks")))
                ("c" "Insert project idea" plain
                 ,pm/note-idea-entry
                 :target (file+head+olp
                          ,pm/project-note-name-template
                          ,(pm/template-head-builder
                            :tags '("project")
                            :headings '("Abstract" "Tasks" "Ideas"))
                          ,'("Ideas"))))
   :node node
   :props '(:unnarrowed t)))

(cl-defun pm/project-capture-new (node)
  (org-roam-capture-
   :goto nil
   :info nil
   :keys nil
   :templates `(("a" "Basic project note" plain
                 ,pm/note-basic-entry
                 :target (file+head+olp
                          ,pm/project-note-name-template
                          ,(pm/template-head-builder
                            :tags '("project")
                            :prompt-for-tags t
                            :headings '("Abstract" "Tasks" "Ideas"))
                          ,'("Abstract"))))
   :node node
   :props '(:unnarrowed t :empty-lines 1)))

(cl-defun pm/project-capture ()
  (interactive)
  (if (file-directory-p (concat org-directory "/project"))
      nil
    (progn
      (make-directory (concat org-directory "/project"))))
  (let ((node (pm/project-read)))
    (if (org-roam-node-file node)
        (pm/project-capture-existing node)
      (pm/project-capture-new node))))

(pm/leader
  "np" '(pm/project-capture :which-key "capture project"))
#+end_src
**** Daily
**** Entities

People/Groups/Companies

Classification is an individual person or groups of people, possibly with multiple unique identifiers

*** Keybinds
**** Generic
#+begin_src emacs-lisp
;; (cl-defun pm/note-capture ()
;;   (interactive)
;;   (let ((node (org-roam-node-create :title "SOME")))
;;     (org-roam-capture-
;;      :goto t
;;      :info "MY INFO"
;;      :keys nil
;;      :templates `(("d" "" plain
;;                     ,pm/note-basic-entry
;;                     :target ,pm/basic-note-target
;;                     :unnarrowed t
;;                     :empty-lines-before 1))
;;      :node node;; (org-roam-node-read nil nil) ;; always captures new note?
;;      :props '() ;; properties to be passed along
;;      )))

;; (cl-defun pm/note-capture-with-title (&key)
;;   (interactive)
;;   (let ((node (org-roam-node-create :title "MY BULLSHIT")))
;;     (org-roam-capture-
;;      :goto t
;;      :info "MY INFO"
;;      :keys nil
;;      :templates `(("d" "" plain
;;                     ,pm/note-basic-entry
;;                     :target ,pm/basic-note-target
;;                     :unnarrowed t
;;                     :empty-lines-before 1))
;;      :node node;; (org-roam-node-read nil nil) ;; always captures new note?
;;      :props '() ;; properties to be passed along
;;      )))

#+end_src

*** Functions

**** intersperse

#+begin_src emacs-lisp :tangle ./functions.el
(defun pm/intersperse (lst value)
  "Intersperse LST with VALUE."
  (if (null lst)
      '()
    (let ((rest-of-list (cdr lst)))
      (if (null rest-of-list)
          lst
        (cons (car lst) (cons value (pm/intersperse rest-of-list value)))))))

#+end_src
**** list-to-org

#+begin_src emacs-lisp :tangle ./functions.el
(defun pm/list-to-org (lst &optional level)
  (unless level (setq level 1))
  (mapconcat (lambda (item)
               (if (listp item)
                   (pm/list-to-org item (1+ level))
                 (concat (make-string level ?*) " " item "\n\n")))
             lst
             ""))
#+end_src
**** list2str
#+begin_src emacs-lisp :tangle ./functions.el
(cl-defun pm/list2str (lst &key (between "") (before "") (after ""))
  (apply #'concat `(,before ,(apply #'concat (pm/intersperse (cl-remove-if-not 'stringp lst) between)) ,after)))
#+end_src
**** template-head-builder

#+begin_src emacs-lisp :tangle ./functions.el
(cl-defun pm/template-head-builder (&key (title "${title}")
                                         (tags `())
                                         (aliases `())
                                         (refs `())
                                         (headings `())
                                         (prompt-for-tags nil)
                                         (created "#+created_at: %U")
                                         (modified  "#+last_modified: %U"))
  "This function is the default builder for all note templates. It expects a series of keys and values in each case:
"
  (let
      ((file-tags (if (or
                       (> (length tags) 0)
                       prompt-for-tags)
                      (pm/list2str tags
                                   :before (concat "#+filetags: "
                                                   (if (> (length tags) 0) ":" ""))
                                   :after (concat (if (> (length tags) 0) ":" "")
                                                  (if prompt-for-tags "%^G" ""))
                                   :between ":")
                    nil))
       (properties (if (or
                        (> (length refs) 0)
                        (> (length aliases) 0))
                       (pm/list2str
                        `(,(when (> (length aliases) 0)
                             (pm/list2str aliases :between " " :before ":ROAM_ALIASES: " :after "\n"))
                          ,(when (> (length refs) 0)
                             (pm/list2str refs :between " " :before ":ROAM_REFS: " :after "\n")))
                        :before ":PROPERTIES:\n"
                        :after ":END:"
                        :between "\n")
                     nil))
       (olp (if (> (length headings) 0)
                (concat "\n" (pm/list-to-org headings))
              nil)))
    (pm/list2str `(,properties
                   ,(concat "#+title: " title)
                   ,created
                   ,modified
                   ,file-tags
                   ,olp
                   )
                 :between "\n")))
#+end_src
**** template-entry-builder

#+begin_src emacs-lisp :tangle ./functions.el
(cl-defun pm/template-entry-builder (&key (todo-state nil)
                                          (title-content nil)
                                          (entry-content nil)
                                          (levels 0)
                                          (tags `())
                                          (no-properties nil))
  (message todo-state)
  (let
      ((tag-str (if (> (length tags) 0)
                    (pm/list2str tags :between ":" :before " :" :after ":")
                  nil))
       (levels-str (if (> levels 0)
                       (make-string levels ?*)
                     nil)))
    (pm/list2str `(,(when (> levels 0) (pm/list2str `(,levels-str
                                                      ,todo-state
                                                      ,title-content
                                                      ,tag-str)
                                                    :between " "))
                   ,(unless no-properties ":PROPERTIES:\n:CREATED:  %U\n:END:")
                   ,(when entry-content entry-content))
                 :between "\n")))
#+end_src

** Notes_TO_DELETE
*** Structure
The notes system I wish to create encompasses many areas but in general it is desired to become my /Personal Knowledge Management System/ - which in short is a process of collecting information that I can use to gather, classify, store, search, retrieve and share knowledge on my daily activities.

One of the major requirements in this is that it should be reasonably easy to use. It should be accepted that cruft will build up and breaking changes may emerge where process of note-taking or management is removed or edited. Building a custom Emacs configuration intends to tailor this for me such that it is reasonably easy to build on.

This will all be facilitated by Org Roam which is a tool for note-taking which reflects the nature of how thoughts and ideas are "networked". The Zettelkasten method, german for "slip-box" is a bi-directional referencing framework for notes enabling a web of thought to develop for a certain idea. Notes should be simple and short. Org Roam does this by creating a unique ~ref~ id per note and inserting all note references into a database for more performative lookups.

Along with this, Org Roam comes with some useful tooling like capture templates for creating all kinds of notes which can be useful outside of just generic note taking in a scholastic sense. Also, it includes a daily journal system which also can be utilised in a number of ways.

The point I wish to emphasise is that Org Roam and it's baseline features will be the foundation tooling of an ecosystem of ~.org~ files which I will use to manage my life. It will also heavily use ~org-agenda~ and maybe even so far as integrating email. As I have multiple machines, typically a laptop, desktop and maybe even a phone, notes ought to be synced between devices automatically. Syncthing is a good solution for this but a more systematic approach of a cloud server to do periodic git updates as backups might prove useful.
In effect, it will be a large substrate data layer on top of my OS which emacs knows how to parse and update. Luckily, since NixOS has emerged, this is a lot easier to maintain. 

The general structure I wish to have is as follows:

- Everything exists under ~~/notes~
- An ~inbox.org~ for capturing random notes
  - Alternatively, this could be done using the daily file?
- All conceptual notes either exists within a flat hierarchy in the top-level directory or under a folder
- Management of note structure and categorisation is maintained through capture templates
  - This will incur some degree of manual labor if things change
- Agenda specific notes come in two kinds
  - "chores" which are a catchall for buckets of tasks I have to do as a part of my life
    - Think doctors appointments, or to clean the house
    - Or things I might like to buy
    - Maybe these are better referred to as LIFE notes as the catchall
    - The sole intent is to be a place I can insert tasks related to that category
    - E.g, my car needs to be serviced, there should be a Car note which I can use to insert a task for that
    - I would expect notes like this can live in a single file, maybe life.org with each category as note headings such that they can be referenced by org-roam
  - Project notes are the other kind
    - These should follow a specific structure, at least identifiable as a project
    - Can vary to all kinds of things like
      - Managing a software project
      - Buying a house
      - Personal Finances
      - A blog
      - Even this org configuration
    - Are more closely related to informational notes and will often link to them
    - All project files should live under ~~/notes/projects~ 
    - In terms of structure, headings like below can be used
      - "Tasks", for bucketing project specific tasks
      - "Purpose/Description", what does this project do?
      - "Notes", general purpose heading
      - "Links", links related to the project
    - Projects should be uniquely identified, like a url reference, but not always necessary
    - There can be different types of projects which might extend the general structure 
      - software project
        - could include a kanban board
        - reference github as unique identifier
        - automatically link to cloned repository under ~~/code~
      - health/fitness tracking
        - Goals could be a concrete task type
        - Could extract sleep information from whatever app I'm using
        - Recipe's for certain meals - can be used to reference a shopping list
      - running a business
        - Collecting meeting notes
        - Managing finances
        - daily journal
    - Project notes are a broad category of long lived or perpetual tasks
      - Are what I make of them
      - Most important point is that they keep track of the state of that project and are a vessel for thinking about that project
    - Project notes can and should reference each other
      - Could create a project note for a job I work at
      - This should reference software project notes I work at
      - This could cause some confusion though because should content relating to a meeting for say a website go in the work project note or the software project note.
      - In such cases I think that a separate <company_name> directory should be created for any notes which go in there
        - This would allow for a clear delineation between notes specific to that job
    - One important addition is for my emacs configuration to be clever enough to dynamically create capture templates for each instance
      - In theory, it ought to be possible to include emacs configuration around my notes, but this might be overkill
    - Could also have it for software based projects, to have a project.org file in the repository and symlink it to the project directory. Would mean everything is self contained within the directory
- Daily notes
  - These are used primarily for journaling
  - Could also be used for capturing fleeting notes or todos like inbox.org is tradtionally used
  - I have been thinking on including it as a way to archive tasks
    - Say a task was completed on date X
    - And org-expiry is setup with an expiry of X + 1 week/month
    - I would want to create an archival system which automatically collects all finished tasks
    - It should archive those tasks from the file they existed in as entries in the daily file corresponding to the day they were completed
    - This will reduce clutter
    - Recurring tasks may be problematic as they hang around but enough elisp-fu should make it work
      - Could use all logging entries as information to create the document
    - Ideally, because this involves editing multiple files, the elisp function should enforce a clean git tree in order for any archiving to commence and should possibly leave commit when finished.
    - As the changes are quite destructive, to "undo" where things break is only possible really with git.
    - Specifying an expiry after todos are put in a finished state can also provide stronger assurances that a specific task is "finished"
- Link notes
  - Link notes are essentially anything which is found on the internet with a url
  - Can be anything from news articles, blogs, videos, comments, photos
  - This is essentially a bookmarking bucket
  - I don't envisage a huge amount of note-taking on the basis of
  - In reality, it could serve as a way of wrapping external links with this system
    - Say I have a software project for some tool, like Nix.
    - I have a link for an article someone wrote about using Nix
    - In my Nix project note, I can insert a link note using a capture template using the url
    - Chatgpt-shell/khoj could come in use here
    - I did read about some AI project which could do video summaries
  - By virtue of the type of material, minimal noting should suffice.
    - An interesting video about politics could be added but it doesn't need to be integrated into a mind map
    - If it can be all the better but it is not a requirement
  - One of the things I want to add is the use of tagging for creating a bookmark system for accessing content I always consume
    - A particular website like youtube might have its own note which I add a bookmark tag to
    - Using external tooling, I can parse my link files to generate a list of websites I frequently visit
    - Also I can extend this methodology further with external tooling to look up old links through tags
- Literature notes
  - This is one I am not too sure on including and may not come to pass yet
  - org has a host of tooling for doing academic level research which might come in handy
    - zotero is used for collecting, organizing and citing research
    - org-bibtex/org-roam-bibtex does citation management with the former
    - org-noter, used for side-by-side paper annotating, note-taking, quotes
  - https://rgoswami.me/posts/org-note-workflow/
  - This would be nice to include for making notes about books
  - Also would come in handy for reading papers
  - Same as with links and projects, there are differing categories which can be included
    - books
    - films
    - papers
    - journals
    - Somewhat dependent on zotero
  - Literature notes and Link notes are somewhat similar
    - Ultimate difference is that Literature notes is physical knowledge
      - Even though it has a digital presence
    - Link notes are knowledge which is primarily internet-based content
- People notes
  - Often note taking will reference people
  - Some of these may be personal
    - Which is good for organizing contact numbers, birthday reminders, emails
    - These could go into a people.org file
    - Not entirely necessary to include outside of certain situations
  - Projects may include a people file for referencing people   
  - Also could be notes related to people of relevance
    - i.e, Napolean Bonaparte
  - Maybe to have a ~~/notes/people/~ might be the best approach 
- Blog notes
  - These are actually publishable ~.org~ files for various blog ideas
  - Should exist under ~~notes/blog/~
  - Probably can contain referencing to other org material but there should be a reserved heading ("Content") which is the content to be published.
- Other structures may emerge for various interests but in general, things should be left as non-hierarchial as possible unless abundantly obvious
  - Could also include a ~~/notes/emacs/~ directory to contain notes for emacs packages and content
  - This file could be split into constituent notes and the tangling could compose all code blocks together
  - Might be a bit cumbersome but would make things very easily referenceable
*** Assign ~SPC n~ for notes

#+begin_src emacs-lisp
;; (pm/leader
;;   "n" '(:ignore t :which-key "notes")
;;   "nw" '(:ignore t :which-key "notes in other-window"))
#+end_src

*** Set ~org-directory~

#+begin_src emacs-lisp
;; (setopt org-directory "~/notes")
#+end_src

*** ~org-roam~

Load the package

#+begin_src emacs-lisp
;; (require 'org-roam)
#+end_src

Set the ~org-roam-directory~ to be the same as ~org-directory~

#+begin_src emacs-lisp
;; (setq org-roam-directory org-directory) 
#+end_src

Ensure the database automatically syncs node references

#+begin_src emacs-lisp
;; (org-roam-db-autosync-mode)
#+end_src

*** Node Display

It's possible to customise how notes can be displayed - I've copy-pasted the core functionality from doom emacs which I always like

#+begin_src emacs-lisp
;; (setq org-eldoc-breadcrumb-separator ">")

;; (defun doom-rpartial (fn &rest args)
;;   "Return a partial application of FUN to right-hand ARGS.

;; ARGS is a list of the last N arguments to pass to FUN. The result is a new
;; function which does the same as FUN, except that the last N arguments are fixed
;; at the values with which this function was called."
;;   (declare (side-effect-free t))
;;   (lambda (&rest pre-args)
;;     (apply fn (append pre-args args))))

;; (cl-defmethod org-roam-node-doom-filetitle ((node org-roam-node))
;;   "Return the value of \"#+title:\" (if any) from file that NODE resides in.
;; If there's no file-level title in the file, return empty string."
;;   (or (if (= (org-roam-node-level node) 0)
;;           (org-roam-node-title node)
;;         (org-roam-node-file-title node))
;;       ""))

;; (cl-defmethod org-roam-node-doom-hierarchy ((node org-roam-node))
;;   "Return hierarchy for NODE, constructed of its file title, OLP and direct title.
;; If some elements are missing, they will be stripped out."
;;   (let ((title     (org-roam-node-title node))
;;         (olp       (org-roam-node-olp   node))
;;         (level     (org-roam-node-level node))
;;         (filetitle (org-roam-node-doom-filetitle node))
;;         (separator (propertize org-eldoc-breadcrumb-separator 'face 'shadow)))
;;     (cl-case level
;;       ;; node is a top-level file
;;       (0 filetitle)
;;       ;; node is a level 1 heading
;;       (1 (concat (propertize filetitle 'face '(shadow italic))
;;                  separator title))
;;       ;; node is a heading with an arbitrary outline path
;;       (t (concat (propertize filetitle 'face '(shadow italic))
;;                  separator (propertize (string-join olp separator) 'face '(shadow italic))
;;                  separator title)))))

;; (cl-defmethod org-roam-node-doom-type ((node org-roam-node))
;;   "Return the directory relative to `org-roam-directory' as a note's \"type\"."
;;   (when-let (dir (thread-first
;;                    node
;;                    (org-roam-node-file)
;;                    (file-relative-name org-roam-directory)
;;                    (file-name-directory)))
;;     (directory-file-name dir)))

;; (cl-defmethod org-roam-node-doom-tags ((node org-roam-node))
;;   "Return tags formatted in the same way how they appear in org files."
;;   (cl-remove-if (doom-rpartial
;;                  #'member (delq
;;                            nil (append
;;                                 (list (bound-and-true-p org-archive-tag)
;;                                       (bound-and-true-p org-attach-auto-tag))
;;                                 (bound-and-true-p org-num-skip-tags))))
;;                 (org-roam-node-tags node)))

;; (setq org-roam-node-display-template
;;       (format "${doom-hierarchy:*} %s %s"
;;               (propertize "${doom-type}" 'face 'font-lock-keyword-face)
;;               (propertize "${doom-tags}" 'face '(:inherit org-tag :box nil))))

;; (add-to-list 'org-roam-node-template-prefixes '("doom-tags" . "#"))
;; (add-to-list 'org-roam-node-template-prefixes '("doom-type" . "@"))
#+end_src

*** Assign ~SPC n f~ for finding/creating notes

#+begin_src emacs-lisp
;; (pm/leader
;;   "nf" '(org-roam-node-find :which-key "Find note"))
#+end_src

*** Assign ~SPC n s~ for searching notes buffer toggle

#+begin_src emacs-lisp
;; (pm/leader
;;   "ns" '(consult-org-roam-search :which-key "Search notes"))
#+end_src

*** Don't prompt when capture is aborted

#+begin_src emacs-lisp
;; (defun pm/return-t (orig-fun &rest args)
;;   t)
;; (defun pm/disable-yornp (orig-fun &rest args)
;;   (advice-add 'yes-or-no-p :around #'pm/return-t)
;;   (advice-add 'y-or-n-p :around #'pm/return-t)
;;   (let ((res (apply orig-fun args)))
;;     (advice-remove 'yes-or-no-p #'pm/return-t)
;;     (advice-remove 'y-or-n-p #'pm/return-t)
;;     res))
;; (advice-add 'org-roam-capture--finalize :around #'pm/disable-yornp)
#+end_src

*** Capturing

Capturing is the major process in defining note editing behaviour. There exists a common thread of behaviours across different categories of notes:

- Capturing notes, this means creating a note on demand, out of context of what else the user is doing.
- Inserting notes, this is where a note is found or created in context of the user is doing. Should be immediate and defer to the context so that minimal context switching occurs.
- Actioning notes, this is where some activity, todo, journal, idea, link is inserted for a given note.
- Finding/Searching notes, lookup on notes should be done globally or locally to their category

The following is the envisaged keybinds

- ~SPC n~ :: parent modifer for global note actions
  - ~SPC n~ :: parent modifer for global note capture
    - ~SPC n d~ :: Capture process for a default note
    - ~SPC n a~ :: Capture process for an aliased note
    - ~SPC n e~ :: Capture process for an empty note
  - ~SPC n i~ :: parent modifer for global note insertion
    - ~SPC n i d~ :: Insertion process for a default note
    - ~SPC n i a~ :: Insertion process for an aliased note
    - ~SPC n i e~ :: Insertion process for an empty note
      
  - ~SPC n d~ :: parent modifer for global daily note capture
    - ~SPC n d d~ :: Goto or create today's daily note
    - ~SPC n d t~ :: Capture process for today's daily note task
    - ~SPC n d j~ :: Capture process for today's daily note journal
    - ~SPC n d i~ :: Capture process for today's daily note idea
    - ~SPC n d l~ :: Capture process for today's daily note link
      
    - ~SPC n d y y~ :: Goto or create yesterday's daily note
    - ~SPC n d y t~ :: Capture process for yesterday's daily note task
    - ~SPC n d y j~ :: Capture process for yesterday's daily note journal
    - ~SPC n d y i~ :: Capture process for yesterday's daily note idea
    - ~SPC n d y l~ :: Capture process for yesterday's daily note link
      
    - ~SPC n d t y~ :: Goto or create tomorrow's daily note
    - ~SPC n d t t~ :: Capture process for tomorrow's daily note task
    - ~SPC n d t j~ :: Capture process for tomorrow's daily note journal
    - ~SPC n d t i~ :: Capture process for tomorrow's daily note idea
    - ~SPC n d t l~ :: Capture process for tomorrow's daily note link

It's preferred to only ever use the leader ~SPC n~ path to access notes, ~org-roam-*~ commands should be mitigated as much as possible so that ambiguity cannot occur. Setting the ~org-roam-capture-templates~ to nil and using custom template selection ensures node creation and lookup is more streamlined.

Capture process should be context aware if using visual selection or clipboard contents. Where a piece of text is visually selected, that should be used to autofill the "NODE" field, either directing the user to a matching node or prompting the user to create a new node. Ideally some textual cleanup and error handling should be done on the input string such that it names titles correctly, e.g "a night on the ocean" becomes "A Night on the Ocean". Also should do some error prevention like where a url is not expected, it should not be allowed as a title.
There is also a discernable difference when doing insertion, anticipating that it occurs when writing prose, it's important that context switching does not occur for the user but it should not be preventative either. When inserting a note or link to some other context, a ~q~ action prefix, indicating "quickly", might be used to discern between switching context or not. So in essence, for "non-category" (projects, dailies, life) notes, 4 keybinds for each template ought to exist:

1. Clean note capture, prompting for existing node, if none found, input used for note creation process.
   
2. Clipboard contents capture, sanitizes/parses input, prompts for existing node or roam_ref with input string. 

3. Yank/Insert/Switch capture, grab input string from point, sanitizes input, prompts for existing node, replaces with note reference
 
**** Templates

These are a number of capture templates and associated variables which are used to construct different filepaths and

#+begin_src emacs-lisp
;; (defun pm/formatted-date-string (&optional day-offset)
;;   "Return a formatted date string for the given DAY-OFFSET.
;; If DAY-OFFSET is nil or 0, return today's date.
;; If DAY-OFFSET is 1, return tomorrow's date.
;; If DAY-OFFSET is -1, return yesterday's date."
;;   (let* ((time (if day-offset
;;                    (time-add (current-time) (days-to-time day-offset))
;;                  (current-time)))
;;          (day (string-to-number (format-time-string "%d" time)))
;;          (suffix (cond ((memq day '(11 12 13)) "th")
;;                        ((= 1 (% day 10)) "st")
;;                        ((= 2 (% day 10)) "nd")
;;                        ((= 3 (% day 10)) "rd")
;;                        (t "th"))))
;;     (format-time-string (concat "%A, %e" suffix " of %B, %Y") time)))

;; (defun pm/intersperse (lst value)
;;   "Intersperse LST with VALUE."
;;   (if (null lst)
;;       '()
;;     (let ((rest-of-list (cdr lst)))
;;       (if (null rest-of-list)
;;           lst
;;         (cons (car lst) (cons value (pm/intersperse rest-of-list value)))))))

;; (defun pm/list-to-org (lst &optional level)
;;   (unless level (setq level 1))
;;   (mapconcat (lambda (item)
;;                (if (listp item)
;;                    (pm/list-to-org item (1+ level))
;;                  (concat (make-string level ?*) " " item "\n\n")))
;;              lst
;;              ""))

;; (defun pm/note-head-template (&rest args)
;;   "This function is the default builder for all note templates. It expects a series of keys and values in each case:

;; :alias - expects string, if not specified, is not included
;; :title - expects string, if not otherwise specified, ${title}
;; :tags - expects string, if not specified, is not included
;; :prompt-for-tags - expect boolean, will add prompting for tags
;; :content - expects string, if not specified, is not included
;; "
;;   (let ((title (or (plist-get args :title) "${title}"))
;;         (tags (or (cl-remove-if-not #'stringp (plist-get args :tags)) `()))
;;         (aliases (or (cl-remove-if-not #'stringp (plist-get args :aliases)) `()))
;;         (refs (or (cl-remove-if-not #'stringp (plist-get args :refs)) `()))
;;         (headings (or (plist-get args :headings) `()))
;;         (prompt-for-tags (or (plist-get args :prompt-for-tags) nil))
;;         (created "#+created_at: %U")
;;         (modified "#+last_modified: %U"))
;;     (let
;;         ((file-tags (if (or
;;                          (> (length tags) 0)
;;                          prompt-for-tags)
;;                         (apply #'concat
;;                                `("#+filetags: "
;;                                  ,(if (> (length tags) 0) ":" "")
;;                                  ,(apply #'concat (pm/intersperse tags ":"))
;;                                  ,(if (> (length tags) 0) ":" "")
;;                                  ,(if prompt-for-tags "%^G" "")))
;;                       nil))
;;          (properties (if (or
;;                           (> (length refs) 0)
;;                           (> (length aliases) 0))
;;                          (apply #'concat
;;                                 `(":PROPERTIES:\n"
;;                                   ,(if (> (length aliases) 0)
;;                                        (concat ":ROAM_ALIASES: " (apply #'concat (pm/intersperse aliases " ")) "\n")
;;                                      "")
;;                                   ,(if (> (length refs) 0)
;;                                        (concat ":ROAM_REFS: " (apply #'concat (pm/intersperse refs " ")) "\n")
;;                                      "")
;;                                   ":END:"))
;;                        nil))
;;          (olp (if (> (length headings) 0)
;;                   (pm/list-to-org headings)
;;                 nil)))
;;       (apply #'concat
;;              (pm/intersperse
;;               (cl-remove-if
;;                'null
;;                `(,(when properties properties)
;;                  ,(concat "#+title: " title)
;;                  ,created
;;                  ,modified
;;                  ,(when file-tags file-tags)
;;                  ,(when olp (concat "\n" olp))))
;;               "\n")))))

;; (defun pm/note-todo-entry (&rest args)
;;   (let ((entry (or (plist-get args :entry) "%?"))
;;         (levels (or (plist-get args :levels) "**"))
;;         (todo (or (plist-get args :todo) "TODO")))
;;     (concat levels " " todo " " entry "\n:PROPERTIES:\n:CREATED:  %U\n:END:\n")))
;; (defvar pm/note-journal-entry
;;   "** [%<%T>]\n %?")
;; (defvar pm/note-idea-entry
;;   "** IDEA %?\n:PROPERTIES:\n:CREATED:  %U\n:END:\n")
;; (defvar pm/note-link-entry
;;   "** LINK %(org-cliplink-capture)\n:PROPERTIES:\n:CREATED:  %U\n:END:\n")
#+end_src

**** Generic

The default capture template for all notes should consist of at least the following

#+begin_src emacs-lisp
;; (defvar pm/note-name-template "%<%s>__${slug}.org")
;; (defvar pm/note-head-template (pm/note-head-template :prompt-for-tags t))
;; (defvar pm/aliased-note-head-template (pm/note-head-template :aliases '("%^{ALIAS}") :prompt-for-tags t))
;; (defvar pm/empty-note-head-template (pm/note-head-template))

;; (defvar pm/default-note-capture-template
;;   `("d" "default" plain
;;     "%?"
;;     :target (file+head ,pm/note-name-template ,pm/note-head-template)
;;     :unnarrowed t
;;     :empty-lines-before 1))
;; (defvar pm/aliased-note-capture-template
;;   `("a" "aliased" plain
;;     "%?"
;;     :target (file+head ,pm/note-name-template ,pm/aliased-note-head-template)
;;     :unnarrowed t
;;     :empty-lines-before 1))
;; (defvar pm/empty-note-capture-template
;;   `("e" "empty" entry
;;     ,(pm/note-todo-entry :levels "*" :todo "NOTE" :entry "Write note for \"${title}\"")
;;     :target (file+head ,pm/note-name-template ,pm/empty-note-head-template)
;;     :immediate-finish t
;;     :empty-lines-before 1))

;; ;; disable org-roam-capture process
;; ;; (defun org-roam-capture () nil)
;; (setq org-roam-capture-templates 
;;       `(,pm/default-note-capture-template))
;; ;;   ,pm/aliased-note-capture-template
;; ;;   ,pm/empty-note-capture-template))

;; (defun pm/note-empty-insert-immediate (arg &rest args)
;;   (interactive "P")
;;   (let ((args (cons arg args))
;;         (org-roam-capture-templates `(,(append pm/empty-note-capture-template (list :kill-buffer t)))))
;;     (apply #'org-roam-node-insert args)))

;; (defun pm/note-default ()
;;   (interactive)
;;   (org-roam-capture nil "d"))

;; (defun pm/note-alias ()
;;   (interactive)
;;   (org-roam-capture nil "a"))

;; (defun pm/note-empty ()
;;   (interactive)
;;   (org-roam-capture nil "e"))


;; (defun my/org-roam-find-project ()
;;   (interactive)
;;   ;; Add the project file to the agenda after capture is finished
;;   (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

;;   ;; Select a project file to open, creating it if necessary
;;   (org-roam-node-find
;;    nil
;;    nil
;;    (my/org-roam-filter-by-tag "Project")
;;    :templates
;;    '(("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
;;       :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+category: ${title}\n#+filetags: Project")
;;       :unnarrowed t))))

;; (cl-defun pm/org-roam-node-find (&optional initial-input filter-fn sort-fn &key templates)
;;   "Find and open an Org-roam node by its title or alias.
;; INITIAL-INPUT is the initial input for the prompt.
;; FILTER-FN is a function to filter out nodes: it takes an `org-roam-node',
;; and when nil is returned the node will be filtered out.
;; If OTHER-WINDOW, visit the NODE in another window.
;; The TEMPLATES, if provided, override the list of capture templates (see
;; `org-roam-capture-'.)"
;;   (interactive)
;;   (let ((node (org-roam-node-read initial-input filter-fn sort-fn)))
;;     (if (org-roam-node-file node)
;;         (org-roam-node-visit node t)
;;       (org-roam-capture-
;;        :node node
;;        :templates templates
;;        :props '(:finalize find-file)))))

;; (defun org-roam-node-display (node)
;;   (let (node-contents-list '((org-roam-node-file node)
;;                              (org-roam-node-file-title node)
;;                              (org-roam-node-file-atime node)
;;                              (org-roam-node-file-mtime node)
;;                              (org-roam-node-level node)
;;                              (org-roam-node-point node)
;;                              (org-roam-node-todo node)
;;                              (org-roam-node-priority node)
;;                              (org-roam-node-scheduled node)
;;                              (org-roam-node-deadline node)
;;                              (org-roam-node-title node)
;;                              (org-roam-node-properties node)
;;                              (org-roam-node-olp node)
;;                              (org-roam-node-tags node)
;;                              (org-roam-node-refs node)
;;                              (org-roam-node-aliases node)))
;;     (format "My List: %s" node-contents-list)))

;; (cl-defun pm/org-roam-node-only-find (&optional initial-input filter-fn sort-fn &key templates)
;;   (interactive)
;;   (let ((node (org-roam-node-read initial-input filter-fn sort-fn)))
;;     (if (org-roam-node-file node)
;;         ;; (org-roam-node-visit node t)
;;         (message (format "Note: \"%s\" found" (org-roam-node-title node)))
;;       (user-error "Note: \"%s\" could not be found" (org-roam-node-title node)))))

;; (defun pm/org-roam-node-list ()
;;   (format "%s" org-roam-node-history))

;; (cl-defun pm/note-find (&key (other-window nil))
;;   (interactive)
;;   (let ((node (org-roam-node-read nil nil nil t "[Find Note:]")))
;;     (org-roam-node-file node other-window)))

;; (pm/leader
;;   "nf" `(,pm/note-find :which-key "Find any note")
;;   "nwf" `(,(pm/note-find other-window t) :which-key "Find any note in other window"))
  ;; "na" '(pm/note-alias :which-key "Create aliased note")
  ;; "ne" '(pm/note-empty :which-key "Create empty note"))

;; (defun pm/note-find-or-create ()
;;   ""
;;   (interactive "P")
;;   (org-roam-node-find t nil nil nil)


;; (let ((args (cons arg args))
;;       (org-roam-capture-templates `(,(append pm/empty-note-capture-template (list :kill-buffer t)))))
;;   (apply #'org-roam-node-insert args)))

;; (pm/leader
;;   "na" '(pm/note-alias :which-key "Create aliased note")
;;   "ne" '(pm/note-empty :which-key "Create empty note"))

#+end_src

The following is going to be a note
**** Dailies

Set the default directory under ~org-directory~

#+begin_src emacs-lisp
;; (setq org-roam-dailies-directory "daily/")
#+end_src

Assign the ~org-roam-dailies-capture-templates~ with relevant keybinds.

#+begin_src emacs-lisp
;; (defvar pm/daily-note-name-template "%<%Y-%m-%d>.org")
;; (defvar pm/daily-note-head-template
;;   (pm/note-head-template
;;    :aliases '("%<%Y-%m-%d>")
;;    :title "%(pm/formatted-date-string)"
;;    :headings '("Journal" "Tasks" "Ideas" "Links")))
;; (setopt org-roam-dailies-capture-templates
;;         `(("d" "default" plain
;;            "%?"
;;            :target (file+head ,pm/daily-note-name-template ,pm/daily-note-head-template)
;;            :unnarrowed t)
;;           ("j" "journal" entry
;;            ,pm/note-journal-entry
;;            :target (file+head+olp ,pm/daily-note-name-template ,pm/daily-note-head-template ("Journal"))
;;            :prepend t
;;            :unnarrowed t)
;;           ("t" "task" entry
;;            ,(pm/note-todo-entry)
;;            :target (file+head+olp ,pm/daily-note-name-template ,pm/daily-note-head-template ("Tasks"))
;;            :prepend t
;;            :unnarrowed t)
;;           ("i" "idea" entry
;;            ,pm/note-idea-entry
;;            :target (file+head+olp ,pm/daily-note-name-template ,pm/daily-note-head-template ("Ideas"))
;;            :prepend t
;;            :unnarrowed t)
;;           ("l" "link" entry
;;            ,pm/note-link-entry
;;            :target (file+head+olp ,pm/daily-note-name-template ,pm/daily-note-head-template ("Links"))
;;            :unnarrowed t
;;            :prepend t
;;            :immediate-finish t)))
#+end_src

Add shortcuts so capturing can be done immediately on key press

#+begin_src emacs-lisp
;; (defun pm/daily-note-today-default ()
;;   (interactive)
;;   (org-roam-dailies-goto-today "d"))
;; (defun pm/daily-note-today-journal ()
;;   (interactive)
;;   (org-roam-dailies-capture-today nil "j"))
;; (defun pm/daily-note-today-task ()
;;   (interactive)
;;   (org-roam-dailies-capture-today nil "t"))
;; (defun pm/daily-note-today-idea ()
;;   (interactive)
;;   (org-roam-dailies-capture-today nil "i"))
;; (defun pm/daily-note-today-link ()
;;   (interactive)
;;   (org-roam-dailies-capture-today nil "l"))

;; (defun pm/daily-note-tomorrow-default ()
;;   (interactive)
;;   (org-roam-dailies-goto-tomorrow 1 "d"))
;; (defun pm/daily-note-tomorrow-journal ()
;;   (interactive)
;;   (org-roam-dailies-capture-tomorrow 1 nil "j"))
;; (defun pm/daily-note-tomorrow-task ()
;;   (interactive)
;;   (org-roam-dailies-capture-tomorrow 1 nil "t"))
;; (defun pm/daily-note-tomorrow-idea ()
;;   (interactive)
;;   (org-roam-dailies-capture-tomorrow 1 nil "i"))
;; (defun pm/daily-note-tomorrow-link ()
;;   (interactive)
;;   (org-roam-dailies-capture-tomorrow 1 nil "l"))

;; (defun pm/daily-note-yesterday-default ()
;;   (interactive)
;;   (org-roam-dailies-goto-yesterday 1 "d"))
;; (defun pm/daily-note-yesterday-journal ()
;;   (interactive)
;;   (org-roam-dailies-capture-yesterday 1 nil "j"))
;; (defun pm/daily-note-yesterday-task ()
;;   (interactive)
;;   (org-roam-dailies-capture-yesterday 1 nil "t"))
;; (defun pm/daily-note-yesterday-idea ()
;;   (interactive)
;;   (org-roam-dailies-capture-yesterday 1 nil "i"))
;; (defun pm/daily-note-yesterday-link ()
;;   (interactive)
;;   (org-roam-dailies-capture-yesterday 1 nil "l"))

;; (pm/leader
;;   "nd" '(:ignore t :which-key "todays' notes")
;;   "ndd" '(pm/daily-note-today-default :which-key "goto daily note")
;;   "ndj" '(pm/daily-note-today-journal :which-key "capture journal entry")
;;   "ndt" '(pm/daily-note-today-task :which-key "capture task")
;;   "ndi" '(pm/daily-note-today-idea :which-key "capture idea")
;;   "ndl" '(pm/daily-note-today-link :which-key "capture link"))
  ;; TODO - Need to make title timestring dynamic
  ;; "nt" '(:ignore t :which-key "tomorrows' notes")
  ;; "ntd" '(pm/daily-note-tomorrow-default :which-key "goto daily note")
  ;; "ntj" '(pm/daily-note-tomorrow-journal :which-key "capture journal entry")
  ;; "ntt" '(pm/daily-note-tomorrow-task :which-key "capture task")
  ;; "nti" '(pm/daily-note-tomorrow-idea :which-key "capture idea")
  ;; "ntl" '(pm/daily-note-tomorrow-link :which-key "capture link")
  ;; "ny" '(:ignore t :which-key "yesterdays' notes")
  ;; "nyd" '(pm/daily-note-yesterday-default :which-key "goto daily note")
  ;; "nyj" '(pm/daily-note-yesterday-journal :which-key "capture journal entry")
  ;; "nyt" '(pm/daily-note-yesterday-task :which-key "capture task")
  ;; "nyi" '(pm/daily-note-yesterday-idea :which-key "capture idea")
  ;; "nyl" '(pm/daily-note-yesterday-link :which-key "capture link"))
#+end_src
**** Projects

#+begin_src emacs-lisp
;; (defvar pm/project-note-name-template "%/projects/<%s>__${slug}.org")
;; (defvar pm/project-note-head-template
;;   (pm/note-head-template
;;    :prompt-for-tags t
;;    :refs '("^{PROJECT_URL}")
;;    :headings '("Project Description" "Journal" "Tasks" "Ideas" "Links")))
;; (setopt org-roam-capture-templates
;;         (append org-roam-capture-templates
;;                 `(("p" "projects")
;;                   ("pd" "default project" plain
;;                    "%?"
;;                    :target (file+head+olp ,pm/project-note-name-template ,pm/project-note-head-template ("Project Description"))
;;                    :unnarrowed t)
;;                   ("pj" "journal" entry
;;                    "** %<%T>\n %?"
;;                    :target (file+head+olp ,pm/project-note-name-template ,pm/project-note-head-template ("Journal %(pm/formatted-date-string)"))
;;                    :prepend t
;;                    :unnarrowed t)
;;                   ("pt" "task" entry
;;                    "** TODO %?\n:PROPERTIES:\n:CREATED:  %U\n:END:\n"
;;                    :target (file+head+olp ,pm/project-note-name-template ,pm/project-note-head-template ("Tasks"))
;;                    :prepend t
;;                    :unnarrowed t)
;;                   ("pi" "idea" entry
;;                    "** IDEA %?\n:PROPERTIES:\n:CREATED:  %U\n:END:\n"
;;                    :target (file+head+olp ,pm/project-note-name-template ,pm/project-note-head-template ("Ideas"))
;;                    :prepend t
;;                    :unnarrowed t)
;;                   ("pl" "link" entry
;;                    "** LINK %(org-cliplink-capture)\n:PROPERTIES:\n:CREATED:  %U\n:END:\n"
;;                    :target (file+head+olp ,pm/project-note-name-template ,pm/project-note-head-template ("Links"))
;;                    :unnarrowed t
;;                    :prepend t
;;                    :immediate-finish t))))

;; (defun pm/project-note-default ()
;;   (interactive "P")
;;   (org-roam-capture t "p"))

;; (pm/leader
;;   "np" '(:ignore t :which-key "project notes")
;;   "npd" '(pm/project-note-default :which-key "goto project note")
;;   "npj" '(pm/daily-note-today-journal :which-key "capture journal entry")
;;   ;; "npt" '(pm/daily-note-today-task :which-key "capture task")
;;   ;; "npi" '(pm/daily-note-today-idea :which-key "capture idea")
;;   ;; "npl" '(pm/daily-note-today-link :which-key "capture link")
;;   )
#+end_src

**** Links
**** Functions

Below are useful helpers which can be used to provide quick access

#+begin_src emacs-lisp
;; (defun pm/note-empty-insert-immediate (arg &rest args)
;;   (interactive "P")
;;   (let ((args (cons arg args))
;;         (org-roam-capture-templates `(,(append pm/empty-note-capture-template (list :kill-buffer t)))))
;;     (apply #'org-roam-node-insert args)))

;; (general-define-key
;;  "C-c n i" 'pm/note-empty-insert-immediate)
#+end_src

something1
** Agenda

*** Gather ~.org~ files relevant for agenda

We recurse everything under ~org-directory~

#+begin_src elisp
(setopt org-agenda-files (directory-files-recursively org-directory org-agenda-file-regexp))
#+end_src

*** Assign ~SPC o a~ as agenda menu

#+begin_src emacs-lisp
(defun pm/org-agenda-menu ()
  (interactive)
  (org-agenda))

(pm/leader
  "oa" '(pm/org-agenda-menu :which-key "agenda"))
#+end_src
*** Fix window

#+begin_src emacs-lisp
(setq org-agenda-restore-windows-after-quit t)
#+end_src
* Project Management

Manage projects using projectile

#+begin_src emacs-lisp
(require 'projectile)
(projectile-mode +1)

(add-to-list 'projectile-globally-ignored-directories "/nix/*")

(setq projectile-project-search-path
      '(
        "~/.config/emacs"
        "~/notes"
        ("~/code" . 4)))

(pm/leader
  "p" '(:ignore t :which-key "switch project")
  "pp" '(projectile-switch-project :which-key "switch project")
  "pf" '(projectile-find-file :which-key "find project file")
  "pb" '(projectile-switch-to-buffer :which-key "find project buffer")
  ;; ... add other projectile-specific bindings as needed
  )
(setq projectile-sort-order 'recentf)
(setq projectile-per-project-compilation-buffer t)
;; (use-package projectile  
;;   :straight t
;;   :diminish projectile-mode
;;   :config (projectile-mode)
;;   :custom ((projectile-completion-system 'ivy))
;;   :bind-keymap
;;   ("C-c p" . projectile-command-map)
;;   :init
;;   ;; NOTE: Set this to the folder where you keep your Git repos!
;;   (when (file-directory-p "~/code")
;;     (setq projectile-project-search-path '("~/code")))
;;   (setq projectile-switch-project-action #'projectile-dired))

;; (use-package counsel-projectile  
;;   :straight t
;;   :after projectile
;;   :config (counsel-projectile-mode))
#+end_src

* Completion System

In Emacs, a "completion system" refers to a mechanism that assists users by providing possible completions for a given partial input. This is especially useful in various contexts like typing commands, specifying file names, setting variable values, or even writing code. The completion system anticipates what the user intends to type next and offers suggestions to complete the input, making the interaction more efficient.

The completion system that is to be used is at the centre of any Emacs configuration as it lends itself to prescribing all the ways that user experience is defined. 

** Interfaces

In Emacs, a completion system's interface determines how candidates are presented to the user and how the user interacts with those candidates. Over the years, various interfaces have been developed, each with its own unique characteristics and interaction models. Many examples exist in different contexts:

- Minibuffer
- Vertical Lists
- Grid-based
- Buffer-based
- Popups
- Child Frames

*** Vertico

https://github.com/minad/vertico

Vertico is a minimalistic completion system for Emacs that provides a vertical interface for completion candidates. It stands out due to its simplicity and focus on doing one thing well: offering a streamlined vertical completion UI for the minibuffer. The focus of Vertico is to provide a UI which behaves correctly under all circumstances. By reusing the built-in facilities system, Vertico achieves full compatibility with built-in Emacs completion commands and completion tables. Vertico only provides the completion UI but aims to be highly flexible, extendable and modular.

#+begin_src emacs-lisp
(require 'vertico)
(vertico-mode)

;; Different scroll margin
(setq vertico-scroll-margin 0)

;; Show more candidates
(setq vertico-count 20)

;; Grow and shrink the Vertico minibuffer
(setq vertico-resize t)

;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
(setq vertico-cycle t)
#+end_src

*** Corfu

https://github.com/minad/corfu

Corfu (Completion Overlay Region FUnction) is an Emacs package that provides in-buffer completion using overlays, presenting completion candidates directly in the buffer akin to a popup. It's designed to offer a lightweight and straightforward completion experience. Corfu is a small package, which relies on the Emacs completion facilities and concentrates on providing a polished completion UI. In-buffer completion UIs in Emacs can hook into ~completion-in-region~, which implements the interaction with the user.

#+begin_src emacs-lisp
(require 'corfu)

(global-corfu-mode)
(setq corfu-auto t
      corfu-quit-no-match 'separator)

(setq completion-cycle-threshold 3)
(setq tab-always-indent 'complete)
#+end_src

** Matching and Filtering

In the context of Emacs, "Matching and Filtering" refers to the process of narrowing down a list of candidates based on user input, so that only those items that align with the input criteria remain visible or are presented to the user. This is especially useful in completion systems, where users might be presented with a large number of potential completions and need an efficient way to find the one they're looking for.

*** Orderless

https://github.com/oantolin/orderless

Orderless is an Emacs package that provides a flexible completion style for narrowing down candidates. Instead of requiring users to type the exact prefix or sequence of a candidate, Orderless allows for matching terms in any order, giving users a more relaxed and efficient completion experience.

#+begin_src emacs-lisp
(require 'orderless)
(setq completion-styles '(orderless basic)
      completion-category-overrides '((file (styles basic partial-completion))))
#+end_src

** Search & Navigation

One of the most important features in Emacs is being able to search and navigate such that users can quickly locate, move to, and manipulate text within and across files. There are a variety of features that users may intend to utilise:

- Incremental Search
- Regular Expression Search
- Multi-file Search
- Symbol and Semantic Search
- Buffer and Window Management
- Bookmarks
- History/Recent files
- Project Navigation
- Semantic Navigation

Typically in Emacs, there are a variety of internal and external methods to extend this functionality, typically as part of a generalised completion system and extend minibuffer actions and commands.

*** Consult

https://github.com/minad/consult

Consult (short for "CONtextualized Subcommands LightweighT") is an Emacs package that provides a collection of commands which use the minibuffer for display and completion. Consult enhances the Emacs minibuffer experience by providing a set of commands that offer richer displays, asynchronous operations, and seamless integration with modern completion systems. It's particularly useful for users looking to supercharge their minibuffer-based workflows in Emacs.

#+begin_src emacs-lisp
(require 'consult)
(require 'consult-projectile)
(require 'consult-org-roam)
(require 'consult-notes)
(require 'consult-dir)
#+end_src

** Annotations

Annotations refer to additional pieces of information displayed alongside completion candidates in the minibuffer. These annotations provide context, clarify the nature of the candidates, and help users make more informed selections.

*** Marginalia

https://github.com/minad/marginalia

Marginalia is an Emacs package designed to enhance the completion experience by providing rich annotations to candidates displayed in the minibuffer. When you're selecting from a list of items, Marginalia adds supplementary context and details to each item, helping you make more informed decisions.

#+begin_src emacs-lisp
(require 'marginalia)
(marginalia-mode)
#+end_src
** Actions

Actions refer to operations or commands that can be executed on a selected completion candidate. While the primary purpose of a completion system is to help users select from a list of candidates, often there's a need to perform different operations on these candidates beyond just selecting or inserting them. This is where actions come into play.

*** Embark

https://github.com/oantolin/embark

Embark is an Emacs package that enhances the interactive experience by providing context-specific actions (or "embarkations") on targets, which can be anything from minibuffer completion candidates to text selected in a buffer. Essentially, it allows users to take various actions on different types of data in a context-aware manner. It's not specifically tied to a completion system but is also used heavily there in combination with some of the already listed configuration.

#+begin_src emacs-lisp
(require 'embark)
(require 'embark-consult)

(general-define-key
 "C-." 'embark-act
 "C-;" 'embark-dwim
 "C-h B" 'embark-bindings)

;; Optionally replace the key help with a completing-read interface
(setq prefix-help-command #'embark-prefix-help-command)
;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
;; strategy, if you want to see the documentation from multiple providers.
(add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)


(add-to-list 'display-buffer-alist
             '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
               nil
               (window-parameters (mode-line-format . none))))

(add-hook 'embark-collect-mode-hook 'consult-preview-at-point-mode)
#+end_src

* Programming Languages
** General Configuration
*** Syntax Highlighting
**** Numbers

When programming highlight numbers

#+begin_src emacs-lisp
(require 'highlight-numbers)
(add-hook 'prog-mode-hook 'highlight-numbers-mode)
#+end_src

**** Bracket Delimiters

Add rainbow matching to all delimiters

#+begin_src emacs-lisp
(require 'rainbow-delimiters)
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
#+end_src

*** Line Numbers

List line-numbers by default and make it relative to cursor position

#+begin_src emacs-lisp
(column-number-mode)
(global-display-line-numbers-mode t)
(setq display-line-numbers 'relative)
#+end_src

Ensure a fixed width so that larger files don't interfere with the text in buffer alignment

#+begin_src emacs-lisp
(setq display-line-numbers-width-start t)
#+end_src

*** Bracket Delimiters

Especially useful for lisping

#+begin_src emacs-lisp
(require 'smartparens)
(add-hook 'prog-mode-hook 'smartparens-mode)
#+end_src
** Nix

Nix is a nice language

#+begin_src emacs-lisp
(require 'nix-mode)
(add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-mode))
#+end_src
** Elisp
* Utilities/Tools
** Profiling

~esup~, https://github.com/jschaf/esup is a tool used for profiling emacs startup time.

#+begin_src emacs-lisp
(require 'esup)
#+end_src

** Help

https://github.com/Wilfred/helpful

#+begin_src emacs-lisp
(require 'helpful)

(general-define-key
 "C-h f" 'helpful-function
 "C-h v" 'helpful-variable
 "C-h k" 'helpful-key)
#+end_src
* Functions

All functions here should be tangled into their own file, ~functions.el~ which can then be instantiated at the top of the generated ~config.el~. This will enforce that any function call can be referenced but keep the structure of this document intact.

** Reload Configuration
#+begin_src emacs-lisp ./functions.el
(defun pm/reload-config ()
  "Reloads the emacs configuration"
  (interactive)
  (load-file (concat user-emacs-directory "init.el")))
#+end_src
** Startup Time 

#+begin_src emacs-lisp :tangle ./functions.el
(defun display-startup-time ()
  (message "Emacs ready in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                    (time-subtract after-init-time before-init-time)))
           gcs-done))
#+end_src
* Finalizations

Here is configuration which should end up at the end of the tangled file

** Emacs Configuration Footer

All elisp files should end with this

#+begin_src emacs-lisp
(provide 'config.el)
;;; config.el ends here
#+end_src

#+begin_src emacs-lisp :tangle ./functions.el
(provide 'functions.el)
;;; functions.el ends here
#+end_src
